'use strict';

var Keyboard = require('svelte-keyboard');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Keyboard__default = /*#__PURE__*/_interopDefaultLegacy(Keyboard);

function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
const escaped = {
    '"': '&quot;',
    "'": '&#39;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escape(html) {
    return String(html).replace(/["'&<>]/g, match => escaped[match]);
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
    }
    return component;
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(parent_component ? parent_component.$$.context : []),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, options = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, options);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Toolbar.svelte generated by Svelte v3.29.0 */

const css = {
	code: ".toolbar.svelte-e4q29q{margin-bottom:1em;padding:1em 0;display:flex;justify-content:flex-end;font-family:var(--font);font-size:0.85em;background-color:transparent}button.svelte-e4q29q{cursor:pointer;margin-left:1em;font-size:1em;font-family:var(--font);background-color:var(--accent-color);border-radius:4px;color:var(--main-color);padding:0.75em;border:none;font-weight:400;transition:background-color 150ms}button.svelte-e4q29q:hover{background-color:var(--secondary-highlight-color)}",
	map: "{\"version\":3,\"file\":\"Toolbar.svelte\",\"sources\":[\"Toolbar.svelte\"],\"sourcesContent\":[\"<script>\\n  import { createEventDispatcher } from \\\"svelte\\\";\\n\\n  const dispatch = createEventDispatcher();\\n\\n  export let actions = [\\\"clear\\\", \\\"reveal\\\", \\\"check\\\", \\\"uncheck\\\"];\\n</script>\\n\\n<div class=\\\"toolbar\\\">\\n  {#each actions as action}\\n    {#if action === 'clear'}\\n      <button on:click=\\\"{() => dispatch('event', 'clear')}\\\">Clear</button>\\n    {:else if action === 'reveal'}\\n      <button on:click=\\\"{() => dispatch('event', 'reveal')}\\\">Reveal</button>\\n    {:else if action === 'uncheck'}\\n      <button on:click=\\\"{() => dispatch('event', 'uncheck')}\\\">Uncheck</button>\\n    {:else if action === 'check'}\\n      <button on:click=\\\"{() => dispatch('event', 'check')}\\\">Check</button>\\n    {/if}\\n  {/each}\\n</div>\\n\\n<style>\\n  .toolbar {\\n    margin-bottom: 1em;\\n    padding: 1em 0;\\n    display: flex;\\n    justify-content: flex-end;\\n    font-family: var(--font);\\n    font-size: 0.85em;\\n    background-color: transparent;\\n  }\\n\\n  button {\\n    cursor: pointer;\\n    margin-left: 1em;\\n    font-size: 1em;\\n    font-family: var(--font);\\n    background-color: var(--accent-color);\\n    border-radius: 4px;\\n    color: var(--main-color);\\n    padding: 0.75em;\\n    border: none;\\n    font-weight: 400;\\n    transition: background-color 150ms;\\n  }\\n\\n  button:hover {\\n    background-color: var(--secondary-highlight-color);\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAuBE,QAAQ,cAAC,CAAC,AACR,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,SAAS,CAAE,MAAM,CACjB,gBAAgB,CAAE,WAAW,AAC/B,CAAC,AAED,MAAM,cAAC,CAAC,AACN,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,gBAAgB,CAAE,IAAI,cAAc,CAAC,CACrC,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,OAAO,CAAE,MAAM,CACf,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,gBAAgB,CAAC,KAAK,AACpC,CAAC,AAED,oBAAM,MAAM,AAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,2BAA2B,CAAC,AACpD,CAAC\"}"
};

const Toolbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	const dispatch = createEventDispatcher();
	let { actions = ["clear", "reveal", "check", "uncheck"] } = $$props;
	if ($$props.actions === void 0 && $$bindings.actions && actions !== void 0) $$bindings.actions(actions);
	$$result.css.add(css);

	return `<div class="${"toolbar svelte-e4q29q"}">${each(actions, action => `${action === "clear"
	? `<button class="${"svelte-e4q29q"}">Clear</button>`
	: `${action === "reveal"
		? `<button class="${"svelte-e4q29q"}">Reveal</button>`
		: `${action === "uncheck"
			? `<button class="${"svelte-e4q29q"}">Uncheck</button>`
			: `${action === "check"
				? `<button class="${"svelte-e4q29q"}">Check</button>`
				: ``}`}`}`}`)}
</div>`;
});

var getSecondarilyFocusedCells = ({ cells, focusedDirection, focusedCell }) => {
  const dimension = focusedDirection == "across" ? "x" : "y";
  const otherDimension = focusedDirection == "across" ? "y" : "x";
  const start = focusedCell[dimension];

  const cellsWithDiff = cells
    .filter(
      (cell) =>
        // take out cells in other columns/rows
        cell[otherDimension] == focusedCell[otherDimension]
    )
    .map((cell) => ({
      ...cell,
      // how far is this cell from our focused cell?
      diff: start - cell[dimension],
    }));
    
	cellsWithDiff.sort((a, b) => a.diff - b.diff);

  // highlight all cells in same row/column, without any breaks
  const diffs = cellsWithDiff.map((d) => d.diff);
  const indices = range(Math.min(...diffs), Math.max(...diffs)).map((i) =>
    diffs.includes(i) ? i : " "
  );
  const chunks = indices.join(",").split(", ,");
  const currentChunk = (
    chunks.find(
      (d) => d.startsWith("0,") || d.endsWith(",0") || d.includes(",0,")
    ) || ""
  )
    .split(",")
    .map((d) => +d);

  const secondarilyFocusedCellIndices = cellsWithDiff
    .filter((cell) => currentChunk.includes(cell.diff))
    .map((cell) => cell.index);
  return secondarilyFocusedCellIndices;
};

const range = (min, max) =>
  Array.from({ length: max - min + 1 }, (v, k) => k + min);

var getCellAfterDiff = ({ diff, cells, direction, focusedCell }) => {
  const dimension = direction == "across" ? "x" : "y";
  const otherDimension = direction == "across" ? "y" : "x";
  const start = focusedCell[dimension];
  const absDiff = Math.abs(diff);
  const isDiffNegative = diff < 0;

  const cellsWithDiff = cells
    .filter(
      (cell) =>
        // take out cells in other columns/rows
        cell[otherDimension] == focusedCell[otherDimension] &&
        // take out cells in wrong direction
        (isDiffNegative ? cell[dimension] < start : cell[dimension] > start)
    )
    .map((cell) => ({
      ...cell,
      // how far is this cell from our focused cell?
      absDiff: Math.abs(start - cell[dimension]),
    }));

  cellsWithDiff.sort((a, b) => a.absDiff - b.absDiff);
  return cellsWithDiff[absDiff - 1];
};

function checkMobile() {
	const devices = {
		android: () => navigator.userAgent.match(/Android/i),

		blackberry: () => navigator.userAgent.match(/BlackBerry/i),

		ios: () => navigator.userAgent.match(/iPhone|iPad|iPod/i),

		opera: () => navigator.userAgent.match(/Opera Mini/i),

		windows: () => navigator.userAgent.match(/IEMobile/i),
	};

	return devices.android() ||
		devices.blackberry() ||
		devices.ios() ||
		devices.opera() ||
		devices.windows();
}

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Cell.svelte generated by Svelte v3.29.0 */

const css$1 = {
	code: "g.svelte-1veput.svelte-1veput{cursor:pointer;user-select:none}g.svelte-1veput.svelte-1veput:focus{outline:none}g.is-secondarily-focused.svelte-1veput rect.svelte-1veput{fill:var(--secondary-highlight-color)}g.is-focused.svelte-1veput rect.svelte-1veput{fill:var(--primary-highlight-color)}text.svelte-1veput.svelte-1veput{pointer-events:none;line-height:1;font-family:var(--font);fill:var(--main-color)}.value.svelte-1veput.svelte-1veput{font-size:0.7em;font-weight:400}.number.svelte-1veput.svelte-1veput{font-size:0.3em;font-weight:400;fill:var(--main-color);opacity:0.5}rect.svelte-1veput.svelte-1veput{fill:var(--bg-color);stroke:var(--main-color);stroke-width:0.01em;transition:fill 0.1s ease-out}line.svelte-1veput.svelte-1veput{stroke:var(--main-color);stroke-width:0.02em}",
	map: "{\"version\":3,\"file\":\"Cell.svelte\",\"sources\":[\"Cell.svelte\"],\"sourcesContent\":[\"<script>\\n  export let x;\\n  export let y;\\n  export let value;\\n  export let answer;\\n  export let number;\\n  export let index;\\n  export let custom;\\n  export let changeDelay = 0;\\n  export let isRevealing = false;\\n  export let isChecking = false;\\n  export let isFocused = false;\\n  export let isSecondarilyFocused = false;\\n  export let onFocusCell = () => {};\\n  export let onCellUpdate = () => {};\\n  export let onFocusClueDiff = () => {};\\n  export let onMoveFocus = () => {};\\n  export let onFlipDirection = () => {};\\n  export let onHistoricalChange = () => {};\\n\\n  let element;\\n\\n  $: isFocused, onFocusSelf();\\n  $: correct = answer === value;\\n  $: showCheck = isChecking && value;\\n\\n  function onFocusSelf() {\\n    if (!element) return;\\n    if (isFocused) element.focus();\\n  }\\n\\n  function onKeydown(e) {\\n    if (e.ctrlKey && e.key.toLowerCase() == \\\"z\\\") {\\n      onHistoricalChange(e.shiftKey ? 1 : -1);\\n    }\\n\\n    if (e.ctrlKey) return;\\n    if (e.altKey) return;\\n\\n    if (e.key === \\\"Tab\\\") {\\n      onFocusClueDiff(e.shiftKey ? -1 : 1);\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return;\\n    }\\n\\n    if (e.key == \\\" \\\") {\\n      onFlipDirection();\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return;\\n    }\\n\\n    if ([\\\"Delete\\\", \\\"Backspace\\\"].includes(e.key)) {\\n      onCellUpdate(index, \\\"\\\", -1, true);\\n      return;\\n    }\\n\\n    const isKeyInAlphabet = /^[a-zA-Z()]$/.test(e.key);\\n    if (isKeyInAlphabet) {\\n      onCellUpdate(index, e.key.toUpperCase());\\n      return;\\n    }\\n\\n    const diff = {\\n      ArrowLeft: [\\\"across\\\", -1],\\n      ArrowRight: [\\\"across\\\", 1],\\n      ArrowUp: [\\\"down\\\", -1],\\n      ArrowDown: [\\\"down\\\", 1],\\n    }[e.key];\\n    if (diff) {\\n      onMoveFocus(...diff);\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return;\\n    }\\n  }\\n\\n  function onClick() {\\n    onFocusCell(index);\\n  }\\n\\n  function pop(node, { delay = 0, duration = 250 }) {\\n    return {\\n      delay,\\n      duration,\\n      css: (t) =>\\n        [\\n          `transform: translate(0, ${1 - t}px)`, //\\n        ].join(\\\";\\\"),\\n    };\\n  }\\n</script>\\n\\n<g\\n  class=\\\"cell {custom} cell-{x}-{y}\\\"\\n  class:is-focused=\\\"{isFocused}\\\"\\n  class:is-secondarily-focused=\\\"{isSecondarilyFocused}\\\"\\n  class:is-correct=\\\"{showCheck && correct}\\\"\\n  class:is-incorrect=\\\"{showCheck && !correct}\\\"\\n  transform=\\\"{`translate(${x}, ${y})`}\\\"\\n  tabIndex=\\\"0\\\"\\n  on:click=\\\"{onClick}\\\"\\n  on:keydown=\\\"{onKeydown}\\\"\\n  bind:this=\\\"{element}\\\">\\n  <rect width=\\\"1\\\" height=\\\"1\\\"></rect>\\n\\n  {#if showCheck && !correct}\\n    <line x1=\\\"0\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"0\\\"></line>\\n  {/if}\\n\\n  {#if value}\\n    <text\\n      transition:pop=\\\"{{ y: 5, delay: changeDelay, duration: isRevealing ? 250 : 0 }}\\\"\\n      class=\\\"value\\\"\\n      x=\\\"0.5\\\"\\n      y=\\\"0.9\\\"\\n      text-anchor=\\\"middle\\\">\\n      {value}\\n    </text>\\n  {/if}\\n  <text class=\\\"number\\\" x=\\\"0.08\\\" y=\\\"0.3\\\" text-anchor=\\\"start\\\">{number}</text>\\n</g>\\n\\n<style>\\n  g {\\n    cursor: pointer;\\n    user-select: none;\\n  }\\n\\n  g:focus {\\n    outline: none;\\n  }\\n\\n  g.is-secondarily-focused rect {\\n    fill: var(--secondary-highlight-color);\\n  }\\n\\n  g.is-focused rect {\\n    fill: var(--primary-highlight-color);\\n  }\\n\\n  text {\\n    pointer-events: none;\\n    line-height: 1;\\n    font-family: var(--font);\\n    fill: var(--main-color);\\n  }\\n\\n  .value {\\n    font-size: 0.7em;\\n    font-weight: 400;\\n  }\\n\\n  .number {\\n    font-size: 0.3em;\\n    font-weight: 400;\\n    fill: var(--main-color);\\n    opacity: 0.5;\\n  }\\n\\n  rect {\\n    fill: var(--bg-color);\\n    stroke: var(--main-color);\\n    stroke-width: 0.01em;\\n    transition: fill 0.1s ease-out;\\n  }\\n\\n  line {\\n    stroke: var(--main-color);\\n    stroke-width: 0.02em;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AA6HE,CAAC,4BAAC,CAAC,AACD,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,IAAI,AACnB,CAAC,AAED,6BAAC,MAAM,AAAC,CAAC,AACP,OAAO,CAAE,IAAI,AACf,CAAC,AAED,CAAC,qCAAuB,CAAC,IAAI,cAAC,CAAC,AAC7B,IAAI,CAAE,IAAI,2BAA2B,CAAC,AACxC,CAAC,AAED,CAAC,yBAAW,CAAC,IAAI,cAAC,CAAC,AACjB,IAAI,CAAE,IAAI,yBAAyB,CAAC,AACtC,CAAC,AAED,IAAI,4BAAC,CAAC,AACJ,cAAc,CAAE,IAAI,CACpB,WAAW,CAAE,CAAC,CACd,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,IAAI,CAAE,IAAI,YAAY,CAAC,AACzB,CAAC,AAED,MAAM,4BAAC,CAAC,AACN,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,AAClB,CAAC,AAED,OAAO,4BAAC,CAAC,AACP,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,CAChB,IAAI,CAAE,IAAI,YAAY,CAAC,CACvB,OAAO,CAAE,GAAG,AACd,CAAC,AAED,IAAI,4BAAC,CAAC,AACJ,IAAI,CAAE,IAAI,UAAU,CAAC,CACrB,MAAM,CAAE,IAAI,YAAY,CAAC,CACzB,YAAY,CAAE,MAAM,CACpB,UAAU,CAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,AAChC,CAAC,AAED,IAAI,4BAAC,CAAC,AACJ,MAAM,CAAE,IAAI,YAAY,CAAC,CACzB,YAAY,CAAE,MAAM,AACtB,CAAC\"}"
};

const Cell = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { x } = $$props;
	let { y } = $$props;
	let { value } = $$props;
	let { answer } = $$props;
	let { number } = $$props;
	let { index } = $$props;
	let { custom } = $$props;
	let { changeDelay = 0 } = $$props;
	let { isRevealing = false } = $$props;
	let { isChecking = false } = $$props;
	let { isFocused = false } = $$props;
	let { isSecondarilyFocused = false } = $$props;

	let { onFocusCell = () => {
		
	} } = $$props;

	let { onCellUpdate = () => {
		
	} } = $$props;

	let { onFocusClueDiff = () => {
		
	} } = $$props;

	let { onMoveFocus = () => {
		
	} } = $$props;

	let { onFlipDirection = () => {
		
	} } = $$props;

	let { onHistoricalChange = () => {
		
	} } = $$props;

	let element;

	if ($$props.x === void 0 && $$bindings.x && x !== void 0) $$bindings.x(x);
	if ($$props.y === void 0 && $$bindings.y && y !== void 0) $$bindings.y(y);
	if ($$props.value === void 0 && $$bindings.value && value !== void 0) $$bindings.value(value);
	if ($$props.answer === void 0 && $$bindings.answer && answer !== void 0) $$bindings.answer(answer);
	if ($$props.number === void 0 && $$bindings.number && number !== void 0) $$bindings.number(number);
	if ($$props.index === void 0 && $$bindings.index && index !== void 0) $$bindings.index(index);
	if ($$props.custom === void 0 && $$bindings.custom && custom !== void 0) $$bindings.custom(custom);
	if ($$props.changeDelay === void 0 && $$bindings.changeDelay && changeDelay !== void 0) $$bindings.changeDelay(changeDelay);
	if ($$props.isRevealing === void 0 && $$bindings.isRevealing && isRevealing !== void 0) $$bindings.isRevealing(isRevealing);
	if ($$props.isChecking === void 0 && $$bindings.isChecking && isChecking !== void 0) $$bindings.isChecking(isChecking);
	if ($$props.isFocused === void 0 && $$bindings.isFocused && isFocused !== void 0) $$bindings.isFocused(isFocused);
	if ($$props.isSecondarilyFocused === void 0 && $$bindings.isSecondarilyFocused && isSecondarilyFocused !== void 0) $$bindings.isSecondarilyFocused(isSecondarilyFocused);
	if ($$props.onFocusCell === void 0 && $$bindings.onFocusCell && onFocusCell !== void 0) $$bindings.onFocusCell(onFocusCell);
	if ($$props.onCellUpdate === void 0 && $$bindings.onCellUpdate && onCellUpdate !== void 0) $$bindings.onCellUpdate(onCellUpdate);
	if ($$props.onFocusClueDiff === void 0 && $$bindings.onFocusClueDiff && onFocusClueDiff !== void 0) $$bindings.onFocusClueDiff(onFocusClueDiff);
	if ($$props.onMoveFocus === void 0 && $$bindings.onMoveFocus && onMoveFocus !== void 0) $$bindings.onMoveFocus(onMoveFocus);
	if ($$props.onFlipDirection === void 0 && $$bindings.onFlipDirection && onFlipDirection !== void 0) $$bindings.onFlipDirection(onFlipDirection);
	if ($$props.onHistoricalChange === void 0 && $$bindings.onHistoricalChange && onHistoricalChange !== void 0) $$bindings.onHistoricalChange(onHistoricalChange);
	$$result.css.add(css$1);
	let correct;
	let showCheck;

	correct = answer === value;
	showCheck = isChecking && value;

	return `<g class="${[
		"cell " + escape(custom) + " cell-" + escape(x) + "-" + escape(y) + " svelte-1veput",
		(isFocused ? "is-focused" : "") + " " + (isSecondarilyFocused ? "is-secondarily-focused" : "") + " " + (showCheck && correct ? "is-correct" : "") + " " + (showCheck && !correct ? "is-incorrect" : "")
	].join(" ").trim()}"${add_attribute("transform", `translate(${x}, ${y})`, 0)} tabIndex="${"0"}"${add_attribute("this", element, 1)}><rect width="${"1"}" height="${"1"}" class="${"svelte-1veput"}"></rect>${showCheck && !correct
	? `<line x1="${"0"}" y1="${"1"}" x2="${"1"}" y2="${"0"}" class="${"svelte-1veput"}"></line>`
	: ``}${value
	? `<text class="${"value svelte-1veput"}" x="${"0.5"}" y="${"0.9"}" text-anchor="${"middle"}">${escape(value)}</text>`
	: ``}<text class="${"number svelte-1veput"}" x="${"0.08"}" y="${"0.3"}" text-anchor="${"start"}">${escape(number)}</text></g>`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Puzzle.svelte generated by Svelte v3.29.0 */

const css$2 = {
	code: "section.svelte-ce6hth{position:sticky;top:1em;order:0;flex:1;height:fit-content}section.is-loaded.stacked.svelte-ce6hth{position:relative;top:auto;height:auto;order:-1}svg.svelte-ce6hth{width:100%;display:block;font-size:1px;background:var(--main-color);border:4px solid var(--main-color);box-sizing:border-box}.keyboard.svelte-ce6hth{order:3}@media only screen and (max-width: 720px){section.svelte-ce6hth:not(.is-loaded){position:relative;top:auto;height:auto;order:-1}}",
	map: "{\"version\":3,\"file\":\"Puzzle.svelte\",\"sources\":[\"Puzzle.svelte\"],\"sourcesContent\":[\"<script>\\n  import { onMount, createEventDispatcher } from \\\"svelte\\\";\\n  import Keyboard from \\\"svelte-keyboard\\\";\\n  import getSecondarilyFocusedCells from \\\"./helpers/getSecondarilyFocusedCells.js\\\";\\n  import getCellAfterDiff from \\\"./helpers/getCellAfterDiff.js\\\";\\n  import checkMobile from \\\"./helpers/checkMobile.js\\\";\\n\\n  import Cell from \\\"./Cell.svelte\\\";\\n\\n  export let clues;\\n  export let cells;\\n  export let focusedDirection;\\n  export let focusedCellIndex;\\n  export let focusedCell;\\n  export let isRevealing;\\n  export let isChecking;\\n  export let isDisableHighlight;\\n  export let stacked;\\n  export let revealDuration = 0;\\n  export let showKeyboard;\\n  export let isLoaded;\\n  export let keyboardStyle;\\n\\n  let element;\\n  let cellsHistoryIndex = 0;\\n  let cellsHistory = [];\\n  let focusedCellIndexHistoryIndex = 0;\\n  let focusedCellIndexHistory = [];\\n  let secondarilyFocusedCells = [];\\n  let isMobile = false;\\n  let isPuzzleFocused = false;\\n\\n  const dispatch = new createEventDispatcher();\\n\\n  const numberOfStatesInHistory = 10;\\n  $: w = Math.max(...cells.map((d) => d.x)) + 1;\\n  $: h = Math.max(...cells.map((d) => d.y)) + 1;\\n  $: keyboardVisible =\\n    typeof showKeyboard === \\\"boolean\\\" ? showKeyboard : isMobile;\\n\\n  $: cells, focusedCellIndex, focusedDirection, updateSecondarilyFocusedCells();\\n  $: sortedCellsInDirection = [...cells].sort((a, b) =>\\n    focusedDirection == \\\"down\\\" ? a.x - b.x || a.y - b.y : a.y - b.y || a.x - b.x\\n  );\\n\\n  onMount(() => {\\n    isMobile = checkMobile();\\n  });\\n\\n  function updateSecondarilyFocusedCells() {\\n    secondarilyFocusedCells = getSecondarilyFocusedCells({\\n      cells,\\n      focusedDirection,\\n      focusedCell,\\n    });\\n  }\\n\\n  function onCellUpdate(index, newValue, diff = 1, doReplaceFilledCells) {\\n    doReplaceFilledCells = doReplaceFilledCells || !!cells[index].value;\\n\\n    const dimension = focusedDirection == \\\"across\\\" ? \\\"x\\\" : \\\"y\\\";\\n    const clueIndex = cells[index].clueNumbers[focusedDirection];\\n    const cellsInClue = cells.filter(\\n      (cell) =>\\n        cell.clueNumbers[focusedDirection] == clueIndex &&\\n        (doReplaceFilledCells || !cell.value)\\n    );\\n    const cellsInCluePositions = cellsInClue\\n      .map((cell) => cell[dimension])\\n      .filter(Number.isFinite);\\n    const isAtEndOfClue =\\n      cells[index][dimension] == Math.max(...cellsInCluePositions);\\n\\n    const newCells = [\\n      ...cells.slice(0, index),\\n      { ...cells[index], value: newValue },\\n      ...cells.slice(index + 1),\\n    ];\\n    cellsHistory = [newCells, ...cellsHistory.slice(cellsHistoryIndex)].slice(\\n      0,\\n      numberOfStatesInHistory\\n    );\\n    cellsHistoryIndex = 0;\\n    cells = newCells;\\n\\n    dispatch(\\n      'cellChange', \\n      {\\n        cells,\\n        index, \\n        newValue\\n      }\\n    );\\n\\n    if (isAtEndOfClue && diff > 0) {\\n      onFocusClueDiff(diff);\\n    } else {\\n      onFocusCellDiff(diff, doReplaceFilledCells);\\n    }\\n  }\\n\\n  function onHistoricalChange(diff) {\\n    cellsHistoryIndex += -diff;\\n    cells = cellsHistory[cellsHistoryIndex] || cells;\\n    focusedCellIndexHistoryIndex += -diff;\\n    focusedCellIndex =\\n      focusedCellIndexHistory[cellsHistoryIndex] || focusedCellIndex;\\n  }\\n\\n  function onFocusCell(index) {\\n    if (isPuzzleFocused && index == focusedCellIndex) {\\n      onFlipDirection();\\n    } else {\\n      focusedCellIndex = index;\\n      \\n      if (!cells[focusedCellIndex].clueNumbers[focusedDirection]) {\\n        const newDirection = focusedDirection === \\\"across\\\" ? \\\"down\\\" : \\\"across\\\";\\n        focusedDirection = newDirection\\n      }\\n\\n      focusedCellIndexHistory = [\\n        index,\\n        ...focusedCellIndexHistory.slice(0, numberOfStatesInHistory),\\n      ];\\n      focusedCellIndexHistoryIndex = 0;\\n    }\\n  }\\n\\n  function onFocusCellDiff(diff, doReplaceFilledCells = true) {\\n    const sortedCellsInDirectionFiltered = sortedCellsInDirection.filter((d) =>\\n      doReplaceFilledCells ? true : !d.value\\n    );\\n    const currentCellIndex = sortedCellsInDirectionFiltered.findIndex(\\n      (d) => d.index == focusedCellIndex\\n    );\\n    const nextCellIndex = (\\n      sortedCellsInDirectionFiltered[currentCellIndex + diff] || {}\\n    ).index;\\n    const nextCell = cells[nextCellIndex];\\n    if (!nextCell) return;\\n    onFocusCell(nextCellIndex);\\n  }\\n\\n  function onFocusClueDiff(diff = 1) {\\n    const currentNumber = focusedCell.clueNumbers[focusedDirection];\\n    let nextCluesInDirection = clues.filter(\\n      (clue) =>\\n        !clue.isFilled &&\\n        (diff > 0\\n          ? clue.number > currentNumber\\n          : clue.number < currentNumber) &&\\n        clue.direction == focusedDirection\\n    );\\n    if (diff < 0) {\\n      nextCluesInDirection = nextCluesInDirection.reverse();\\n    }\\n    let nextClue = nextCluesInDirection[Math.abs(diff) - 1];\\n    if (!nextClue) {\\n      onFlipDirection();\\n      nextClue = clues.filter((clue) => clue.direction == focusedDirection)[0];\\n    }\\n    const nextFocusedCell =\\n      sortedCellsInDirection.find(\\n        (cell) =>\\n          !cell.value && cell.clueNumbers[focusedDirection] == nextClue.number\\n      ) || {};\\n    focusedCellIndex = nextFocusedCell.index || 0;\\n  }\\n\\n  function onMoveFocus(direction, diff) {\\n    if (focusedDirection != direction) {\\n      const dimension = direction == \\\"across\\\" ? \\\"x\\\" : \\\"y\\\";\\n      focusedDirection = direction;\\n    } else {\\n      const nextCell = getCellAfterDiff({\\n        diff,\\n        cells,\\n        direction,\\n        focusedCell,\\n      });\\n      if (!nextCell) return;\\n      onFocusCell(nextCell.index);\\n    }\\n  }\\n\\n  function onFlipDirection() {\\n    const newDirection = focusedDirection === \\\"across\\\" ? \\\"down\\\" : \\\"across\\\";\\n    const hasClueInNewDirection = !!focusedCell[\\\"clueNumbers\\\"][newDirection];\\n    if (hasClueInNewDirection) focusedDirection = newDirection;\\n  }\\n\\n  function onKeydown({ detail }) {\\n    const diff = detail === \\\"Backspace\\\" ? -1 : 1;\\n    const value = detail === \\\"Backspace\\\" ? \\\"\\\" : detail;\\n    onCellUpdate(focusedCellIndex, value, diff);\\n  }\\n\\n  function onClick() {\\n    isPuzzleFocused = element.contains(document.activeElement);\\n  }\\n</script>\\n\\n<svelte:window on:click=\\\"{onClick}\\\" />\\n\\n<section\\n  class=\\\"puzzle\\\"\\n  class:stacked\\n  class:is-loaded=\\\"{isLoaded}\\\"\\n  bind:this=\\\"{element}\\\">\\n  <svg viewBox=\\\"0 0 {w} {h}\\\">\\n    {#each cells as { x, y, value, answer, index, number, custom }}\\n      <Cell\\n        x=\\\"{x}\\\"\\n        y=\\\"{y}\\\"\\n        index=\\\"{index}\\\"\\n        value=\\\"{value}\\\"\\n        answer=\\\"{answer}\\\"\\n        number=\\\"{number}\\\"\\n        custom=\\\"{custom}\\\"\\n        changeDelay=\\\"{isRevealing ? (revealDuration / cells.length) * index : 0}\\\"\\n        isRevealing=\\\"{isRevealing}\\\"\\n        isChecking=\\\"{isChecking}\\\"\\n        isFocused=\\\"{focusedCellIndex == index && !isDisableHighlight}\\\"\\n        isSecondarilyFocused=\\\"{secondarilyFocusedCells.includes(index) && !isDisableHighlight}\\\"\\n        onFocusCell=\\\"{onFocusCell}\\\"\\n        onCellUpdate=\\\"{onCellUpdate}\\\"\\n        onFocusClueDiff=\\\"{onFocusClueDiff}\\\"\\n        onMoveFocus=\\\"{onMoveFocus}\\\"\\n        onFlipDirection=\\\"{onFlipDirection}\\\"\\n        onHistoricalChange=\\\"{onHistoricalChange}\\\" />\\n    {/each}\\n  </svg>\\n</section>\\n\\n{#if keyboardVisible}\\n  <div class=\\\"keyboard\\\">\\n    <Keyboard\\n      layout=\\\"crossword\\\"\\n      style=\\\"{keyboardStyle}\\\"\\n      on:keydown=\\\"{onKeydown}\\\" />\\n  </div>\\n{/if}\\n\\n<style>\\n  section {\\n    position: sticky;\\n    top: 1em;\\n    order: 0;\\n    flex: 1;\\n    height: fit-content;\\n  }\\n\\n  section.is-loaded.stacked {\\n    position: relative;\\n    top: auto;\\n    height: auto;\\n    order: -1;\\n  }\\n\\n  svg {\\n    width: 100%;\\n    display: block;\\n    font-size: 1px;\\n    background: var(--main-color);\\n    border: 4px solid var(--main-color);\\n    box-sizing: border-box;\\n  }\\n\\n  .keyboard {\\n    order: 3;\\n  }\\n\\n  @media only screen and (max-width: 720px) {\\n    section:not(.is-loaded) {\\n      position: relative;\\n      top: auto;\\n      height: auto;\\n      order: -1;\\n    }\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAoPE,OAAO,cAAC,CAAC,AACP,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,GAAG,CACR,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CACP,MAAM,CAAE,WAAW,AACrB,CAAC,AAED,OAAO,UAAU,QAAQ,cAAC,CAAC,AACzB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,EAAE,AACX,CAAC,AAED,GAAG,cAAC,CAAC,AACH,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,KAAK,CACd,SAAS,CAAE,GAAG,CACd,UAAU,CAAE,IAAI,YAAY,CAAC,CAC7B,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,CACnC,UAAU,CAAE,UAAU,AACxB,CAAC,AAED,SAAS,cAAC,CAAC,AACT,KAAK,CAAE,CAAC,AACV,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,qBAAO,KAAK,UAAU,CAAC,AAAC,CAAC,AACvB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,EAAE,AACX,CAAC,AACH,CAAC\"}"
};

const numberOfStatesInHistory = 10;

const Puzzle = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { clues } = $$props;
	let { cells } = $$props;
	let { focusedDirection } = $$props;
	let { focusedCellIndex } = $$props;
	let { focusedCell } = $$props;
	let { isRevealing } = $$props;
	let { isChecking } = $$props;
	let { isDisableHighlight } = $$props;
	let { stacked } = $$props;
	let { revealDuration = 0 } = $$props;
	let { showKeyboard } = $$props;
	let { isLoaded } = $$props;
	let { keyboardStyle } = $$props;
	let element;
	let cellsHistoryIndex = 0;
	let cellsHistory = [];
	let focusedCellIndexHistory = [];
	let secondarilyFocusedCells = [];
	let isMobile = false;
	const dispatch = new createEventDispatcher();

	onMount(() => {
		isMobile = checkMobile();
	});

	function updateSecondarilyFocusedCells() {
		secondarilyFocusedCells = getSecondarilyFocusedCells({ cells, focusedDirection, focusedCell });
	}

	function onCellUpdate(index, newValue, diff = 1, doReplaceFilledCells) {
		doReplaceFilledCells = doReplaceFilledCells || !!cells[index].value;
		const dimension = focusedDirection == "across" ? "x" : "y";
		const clueIndex = cells[index].clueNumbers[focusedDirection];
		const cellsInClue = cells.filter(cell => cell.clueNumbers[focusedDirection] == clueIndex && (doReplaceFilledCells || !cell.value));
		const cellsInCluePositions = cellsInClue.map(cell => cell[dimension]).filter(Number.isFinite);
		const isAtEndOfClue = cells[index][dimension] == Math.max(...cellsInCluePositions);

		const newCells = [
			...cells.slice(0, index),
			{ ...cells[index], value: newValue },
			...cells.slice(index + 1)
		];

		cellsHistory = [newCells, ...cellsHistory.slice(cellsHistoryIndex)].slice(0, numberOfStatesInHistory);
		cellsHistoryIndex = 0;
		cells = newCells;
		dispatch("cellChange", { cells, index, newValue });

		if (isAtEndOfClue && diff > 0) {
			onFocusClueDiff(diff);
		} else {
			onFocusCellDiff(diff, doReplaceFilledCells);
		}
	}

	function onHistoricalChange(diff) {
		cellsHistoryIndex += -diff;
		cells = cellsHistory[cellsHistoryIndex] || cells;
		focusedCellIndex = focusedCellIndexHistory[cellsHistoryIndex] || focusedCellIndex;
	}

	function onFocusCell(index) {
		{
			focusedCellIndex = index;

			if (!cells[focusedCellIndex].clueNumbers[focusedDirection]) {
				const newDirection = focusedDirection === "across" ? "down" : "across";
				focusedDirection = newDirection;
			}

			focusedCellIndexHistory = [index, ...focusedCellIndexHistory.slice(0, numberOfStatesInHistory)];
		}
	}

	function onFocusCellDiff(diff, doReplaceFilledCells = true) {
		const sortedCellsInDirectionFiltered = sortedCellsInDirection.filter(d => doReplaceFilledCells ? true : !d.value);
		const currentCellIndex = sortedCellsInDirectionFiltered.findIndex(d => d.index == focusedCellIndex);
		const nextCellIndex = (sortedCellsInDirectionFiltered[currentCellIndex + diff] || {}).index;
		const nextCell = cells[nextCellIndex];
		if (!nextCell) return;
		onFocusCell(nextCellIndex);
	}

	function onFocusClueDiff(diff = 1) {
		const currentNumber = focusedCell.clueNumbers[focusedDirection];

		let nextCluesInDirection = clues.filter(clue => !clue.isFilled && (diff > 0
		? clue.number > currentNumber
		: clue.number < currentNumber) && clue.direction == focusedDirection);

		if (diff < 0) {
			nextCluesInDirection = nextCluesInDirection.reverse();
		}

		let nextClue = nextCluesInDirection[Math.abs(diff) - 1];

		if (!nextClue) {
			onFlipDirection();
			nextClue = clues.filter(clue => clue.direction == focusedDirection)[0];
		}

		const nextFocusedCell = sortedCellsInDirection.find(cell => !cell.value && cell.clueNumbers[focusedDirection] == nextClue.number) || {};
		focusedCellIndex = nextFocusedCell.index || 0;
	}

	function onMoveFocus(direction, diff) {
		if (focusedDirection != direction) {
			focusedDirection = direction;
		} else {
			const nextCell = getCellAfterDiff({ diff, cells, direction, focusedCell });
			if (!nextCell) return;
			onFocusCell(nextCell.index);
		}
	}

	function onFlipDirection() {
		const newDirection = focusedDirection === "across" ? "down" : "across";
		const hasClueInNewDirection = !!focusedCell["clueNumbers"][newDirection];
		if (hasClueInNewDirection) focusedDirection = newDirection;
	}

	if ($$props.clues === void 0 && $$bindings.clues && clues !== void 0) $$bindings.clues(clues);
	if ($$props.cells === void 0 && $$bindings.cells && cells !== void 0) $$bindings.cells(cells);
	if ($$props.focusedDirection === void 0 && $$bindings.focusedDirection && focusedDirection !== void 0) $$bindings.focusedDirection(focusedDirection);
	if ($$props.focusedCellIndex === void 0 && $$bindings.focusedCellIndex && focusedCellIndex !== void 0) $$bindings.focusedCellIndex(focusedCellIndex);
	if ($$props.focusedCell === void 0 && $$bindings.focusedCell && focusedCell !== void 0) $$bindings.focusedCell(focusedCell);
	if ($$props.isRevealing === void 0 && $$bindings.isRevealing && isRevealing !== void 0) $$bindings.isRevealing(isRevealing);
	if ($$props.isChecking === void 0 && $$bindings.isChecking && isChecking !== void 0) $$bindings.isChecking(isChecking);
	if ($$props.isDisableHighlight === void 0 && $$bindings.isDisableHighlight && isDisableHighlight !== void 0) $$bindings.isDisableHighlight(isDisableHighlight);
	if ($$props.stacked === void 0 && $$bindings.stacked && stacked !== void 0) $$bindings.stacked(stacked);
	if ($$props.revealDuration === void 0 && $$bindings.revealDuration && revealDuration !== void 0) $$bindings.revealDuration(revealDuration);
	if ($$props.showKeyboard === void 0 && $$bindings.showKeyboard && showKeyboard !== void 0) $$bindings.showKeyboard(showKeyboard);
	if ($$props.isLoaded === void 0 && $$bindings.isLoaded && isLoaded !== void 0) $$bindings.isLoaded(isLoaded);
	if ($$props.keyboardStyle === void 0 && $$bindings.keyboardStyle && keyboardStyle !== void 0) $$bindings.keyboardStyle(keyboardStyle);
	$$result.css.add(css$2);
	let w;
	let h;
	let keyboardVisible;
	let sortedCellsInDirection;
	w = Math.max(...cells.map(d => d.x)) + 1;
	h = Math.max(...cells.map(d => d.y)) + 1;

	keyboardVisible = typeof showKeyboard === "boolean"
	? showKeyboard
	: isMobile;

	 {
		(updateSecondarilyFocusedCells());
	}

	sortedCellsInDirection = [...cells].sort((a, b) => focusedDirection == "down"
	? a.x - b.x || a.y - b.y
	: a.y - b.y || a.x - b.x);

	return `

<section class="${[
		"puzzle svelte-ce6hth",
		(stacked ? "stacked" : "") + " " + (isLoaded ? "is-loaded" : "")
	].join(" ").trim()}"${add_attribute("this", element, 1)}><svg viewBox="${"0 0 " + escape(w) + " " + escape(h)}" class="${"svelte-ce6hth"}">${each(cells, ({ x, y, value, answer, index, number, custom }) => `${validate_component(Cell, "Cell").$$render(
		$$result,
		{
			x,
			y,
			index,
			value,
			answer,
			number,
			custom,
			changeDelay: isRevealing ? revealDuration / cells.length * index : 0,
			isRevealing,
			isChecking,
			isFocused: focusedCellIndex == index && !isDisableHighlight,
			isSecondarilyFocused: secondarilyFocusedCells.includes(index) && !isDisableHighlight,
			onFocusCell,
			onCellUpdate,
			onFocusClueDiff,
			onMoveFocus,
			onFlipDirection,
			onHistoricalChange
		},
		{},
		{}
	)}`)}</svg></section>

${keyboardVisible
	? `<div class="${"keyboard svelte-ce6hth"}">${validate_component(Keyboard__default['default'], "Keyboard").$$render(
			$$result,
			{
				layout: "crossword",
				style: keyboardStyle
			},
			{},
			{}
		)}</div>`
	: ``}`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Clue.svelte generated by Svelte v3.29.0 */

const css$3 = {
	code: "button.svelte-hozmon{display:flex;width:100%;background:none;text-align:left;appearance:none;outline:none;border:none;border-left:6px solid transparent;padding:0.5em;cursor:pointer;line-height:1.325;color:var(--main-color);font-family:var(--font);font-size:1em;cursor:pointer}strong.svelte-hozmon{min-width:1.25em;display:inline-block;text-align:right;margin-right:0.5em}.clue.svelte-hozmon:focus:not(.is-disable-highlight){border-color:var(--secondary-highlight-color)}.is-number-focused.svelte-hozmon:not(.is-disable-highlight){border-left-color:var(--secondary-highlight-color)}.is-number-focused.is-direction-focused.svelte-hozmon:not(.is-disable-highlight){background:var(--secondary-highlight-color)}.is-filled.svelte-hozmon{opacity:0.5}",
	map: "{\"version\":3,\"file\":\"Clue.svelte\",\"sources\":[\"Clue.svelte\"],\"sourcesContent\":[\"<script>\\n  import scrollTo from \\\"./helpers/scrollTo.js\\\";\\n\\n  export let number;\\n  export let clue;\\n  export let custom;\\n  export let isFilled;\\n  export let isNumberFocused = false;\\n  export let isDirectionFocused = false;\\n  export let isDisableHighlight = false;\\n  export let onFocus = () => {};\\n\\n  let element;\\n\\n  $: isFocused = isNumberFocused;\\n</script>\\n\\n<li bind:this=\\\"{element}\\\" use:scrollTo=\\\"{isFocused}\\\">\\n  <button\\n    class=\\\"clue {custom}\\\"\\n    class:is-disable-highlight=\\\"{isDisableHighlight}\\\"\\n    class:is-number-focused=\\\"{isNumberFocused}\\\"\\n    class:is-direction-focused=\\\"{isDirectionFocused}\\\"\\n    class:is-filled=\\\"{isFilled}\\\"\\n    on:click=\\\"{onFocus}\\\">\\n    <strong>{number}</strong>\\n    {clue}\\n  </button>\\n</li>\\n\\n<style>\\n  button {\\n    display: flex;\\n    width: 100%;\\n    background: none;\\n    text-align: left;\\n    appearance: none;\\n    outline: none;\\n    border: none;\\n    border-left: 6px solid transparent;\\n    padding: 0.5em;\\n    cursor: pointer;\\n    line-height: 1.325;\\n    color: var(--main-color);\\n    font-family: var(--font);\\n    font-size: 1em;\\n    cursor: pointer;\\n  }\\n\\n  strong {\\n    min-width: 1.25em;\\n    display: inline-block;\\n    text-align: right;\\n    margin-right: 0.5em;\\n  }\\n\\n  .clue:focus:not(.is-disable-highlight) {\\n    border-color: var(--secondary-highlight-color);\\n  }\\n  .is-number-focused:not(.is-disable-highlight) {\\n    border-left-color: var(--secondary-highlight-color);\\n  }\\n  .is-number-focused.is-direction-focused:not(.is-disable-highlight) {\\n    background: var(--secondary-highlight-color);\\n  }\\n  .is-filled {\\n    opacity: 0.5;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AA+BE,MAAM,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,WAAW,CAClC,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,KAAK,CAClB,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,SAAS,CAAE,GAAG,CACd,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,MAAM,cAAC,CAAC,AACN,SAAS,CAAE,MAAM,CACjB,OAAO,CAAE,YAAY,CACrB,UAAU,CAAE,KAAK,CACjB,YAAY,CAAE,KAAK,AACrB,CAAC,AAED,mBAAK,MAAM,KAAK,qBAAqB,CAAC,AAAC,CAAC,AACtC,YAAY,CAAE,IAAI,2BAA2B,CAAC,AAChD,CAAC,AACD,gCAAkB,KAAK,qBAAqB,CAAC,AAAC,CAAC,AAC7C,iBAAiB,CAAE,IAAI,2BAA2B,CAAC,AACrD,CAAC,AACD,kBAAkB,mCAAqB,KAAK,qBAAqB,CAAC,AAAC,CAAC,AAClE,UAAU,CAAE,IAAI,2BAA2B,CAAC,AAC9C,CAAC,AACD,UAAU,cAAC,CAAC,AACV,OAAO,CAAE,GAAG,AACd,CAAC\"}"
};

const Clue = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { number } = $$props;
	let { clue } = $$props;
	let { custom } = $$props;
	let { isFilled } = $$props;
	let { isNumberFocused = false } = $$props;
	let { isDirectionFocused = false } = $$props;
	let { isDisableHighlight = false } = $$props;

	let { onFocus = () => {
		
	} } = $$props;

	let element;
	if ($$props.number === void 0 && $$bindings.number && number !== void 0) $$bindings.number(number);
	if ($$props.clue === void 0 && $$bindings.clue && clue !== void 0) $$bindings.clue(clue);
	if ($$props.custom === void 0 && $$bindings.custom && custom !== void 0) $$bindings.custom(custom);
	if ($$props.isFilled === void 0 && $$bindings.isFilled && isFilled !== void 0) $$bindings.isFilled(isFilled);
	if ($$props.isNumberFocused === void 0 && $$bindings.isNumberFocused && isNumberFocused !== void 0) $$bindings.isNumberFocused(isNumberFocused);
	if ($$props.isDirectionFocused === void 0 && $$bindings.isDirectionFocused && isDirectionFocused !== void 0) $$bindings.isDirectionFocused(isDirectionFocused);
	if ($$props.isDisableHighlight === void 0 && $$bindings.isDisableHighlight && isDisableHighlight !== void 0) $$bindings.isDisableHighlight(isDisableHighlight);
	if ($$props.onFocus === void 0 && $$bindings.onFocus && onFocus !== void 0) $$bindings.onFocus(onFocus);
	$$result.css.add(css$3);

	return `<li${add_attribute("this", element, 1)}><button class="${[
		"clue " + escape(custom) + " svelte-hozmon",
		(isDisableHighlight ? "is-disable-highlight" : "") + " " + (isNumberFocused ? "is-number-focused" : "") + " " + (isDirectionFocused ? "is-direction-focused" : "") + " " + (isFilled ? "is-filled" : "")
	].join(" ").trim()}"><strong class="${"svelte-hozmon"}">${escape(number)}</strong>
    ${escape(clue)}</button>
</li>`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/ClueList.svelte generated by Svelte v3.29.0 */

const css$4 = {
	code: ".list.svelte-16s2wyn{position:relative;max-height:45vh;margin-bottom:2em;overflow:auto}p.svelte-16s2wyn{font-family:var(--font);color:var(--main-color);font-weight:700;text-transform:uppercase;padding-left:calc(2.5em + 6px);padding-bottom:0.5em;font-size:0.85em;border-bottom:1px solid var(--accent-color);margin:0}ul.svelte-16s2wyn{list-style-type:none;padding-left:0;margin:0;margin-top:1em}.svelte-16s2wyn::-moz-scrollbar{width:9px}.svelte-16s2wyn::-webkit-scrollbar{width:9px}.svelte-16s2wyn::-moz-scrollbar-track{box-shadow:none;border-radius:8px;background-color:var(--accent-color)}.svelte-16s2wyn::-webkit-scrollbar-track{box-shadow:none;border-radius:8px;background-color:var(--accent-color)}.svelte-16s2wyn::scrollbar-thumb{border-radius:8px;background-color:var(--scrollbar-color);box-shadow:none}.svelte-16s2wyn::-moz-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:6px}.svelte-16s2wyn::-webkit-scrollbar-thumb{background-color:var(--scrollbar-color);border-radius:6px}",
	map: "{\"version\":3,\"file\":\"ClueList.svelte\",\"sources\":[\"ClueList.svelte\"],\"sourcesContent\":[\"<script>\\n  import Clue from \\\"./Clue.svelte\\\";\\n\\n  export let direction;\\n  export let clues;\\n  export let focusedClueNumbers;\\n  export let isDirectionFocused;\\n  export let onClueFocus;\\n  export let isDisableHighlight;\\n</script>\\n\\n<p>{direction}</p>\\n<div class=\\\"list\\\">\\n  <ul>\\n    {#each clues as clue}\\n      <Clue\\n        clue=\\\"{clue.clue}\\\"\\n        number=\\\"{clue.number}\\\"\\n        custom=\\\"{clue.custom}\\\"\\n        isFilled=\\\"{clue.isFilled}\\\"\\n        isNumberFocused=\\\"{focusedClueNumbers[direction] === clue.number}\\\"\\n        isDirectionFocused=\\\"{isDirectionFocused}\\\"\\n        isDisableHighlight=\\\"{isDisableHighlight}\\\"\\n        onFocus=\\\"{() => onClueFocus(clue)}\\\" />\\n    {/each}\\n  </ul>\\n</div>\\n\\n<style>\\n  .list {\\n    position: relative;\\n    max-height: 45vh;\\n    margin-bottom: 2em;\\n    overflow: auto;\\n  }\\n\\n  p {\\n    font-family: var(--font);\\n    color: var(--main-color);\\n    font-weight: 700;\\n    text-transform: uppercase;\\n    padding-left: calc(2.5em + 6px);\\n    padding-bottom: 0.5em;\\n    font-size: 0.85em;\\n    border-bottom: 1px solid var(--accent-color);\\n    margin: 0;\\n  }\\n\\n  ul {\\n    list-style-type: none;\\n    padding-left: 0;\\n    margin: 0;\\n    margin-top: 1em;\\n  }\\n\\n  ::-moz-scrollbar {\\n    width: 9px;\\n  }\\n  ::-webkit-scrollbar {\\n    width: 9px;\\n  }\\n\\n  ::-moz-scrollbar-track {\\n    box-shadow: none;\\n    border-radius: 8px;\\n    background-color: var(--accent-color);\\n  }\\n  ::-webkit-scrollbar-track {\\n    box-shadow: none;\\n    border-radius: 8px;\\n    background-color: var(--accent-color);\\n  }\\n  ::scrollbar-thumb {\\n    border-radius: 8px;\\n    background-color: var(--scrollbar-color);\\n    box-shadow: none;\\n  }\\n  ::-moz-scrollbar-thumb {\\n    background-color: var(--scrollbar-color);\\n    border-radius: 6px;\\n  }\\n  ::-webkit-scrollbar-thumb {\\n    background-color: var(--scrollbar-color);\\n    border-radius: 6px;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AA6BE,KAAK,eAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,IAAI,CAChB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,IAAI,AAChB,CAAC,AAED,CAAC,eAAC,CAAC,AACD,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,SAAS,CACzB,YAAY,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAC/B,cAAc,CAAE,KAAK,CACrB,SAAS,CAAE,MAAM,CACjB,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,CAC5C,MAAM,CAAE,CAAC,AACX,CAAC,AAED,EAAE,eAAC,CAAC,AACF,eAAe,CAAE,IAAI,CACrB,YAAY,CAAE,CAAC,CACf,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,GAAG,AACjB,CAAC,eAED,gBAAgB,AAAC,CAAC,AAChB,KAAK,CAAE,GAAG,AACZ,CAAC,eACD,mBAAmB,AAAC,CAAC,AACnB,KAAK,CAAE,GAAG,AACZ,CAAC,eAED,sBAAsB,AAAC,CAAC,AACtB,UAAU,CAAE,IAAI,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IAAI,cAAc,CAAC,AACvC,CAAC,eACD,yBAAyB,AAAC,CAAC,AACzB,UAAU,CAAE,IAAI,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IAAI,cAAc,CAAC,AACvC,CAAC,eACD,iBAAiB,AAAC,CAAC,AACjB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IAAI,iBAAiB,CAAC,CACxC,UAAU,CAAE,IAAI,AAClB,CAAC,eACD,sBAAsB,AAAC,CAAC,AACtB,gBAAgB,CAAE,IAAI,iBAAiB,CAAC,CACxC,aAAa,CAAE,GAAG,AACpB,CAAC,eACD,yBAAyB,AAAC,CAAC,AACzB,gBAAgB,CAAE,IAAI,iBAAiB,CAAC,CACxC,aAAa,CAAE,GAAG,AACpB,CAAC\"}"
};

const ClueList = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { direction } = $$props;
	let { clues } = $$props;
	let { focusedClueNumbers } = $$props;
	let { isDirectionFocused } = $$props;
	let { onClueFocus } = $$props;
	let { isDisableHighlight } = $$props;
	if ($$props.direction === void 0 && $$bindings.direction && direction !== void 0) $$bindings.direction(direction);
	if ($$props.clues === void 0 && $$bindings.clues && clues !== void 0) $$bindings.clues(clues);
	if ($$props.focusedClueNumbers === void 0 && $$bindings.focusedClueNumbers && focusedClueNumbers !== void 0) $$bindings.focusedClueNumbers(focusedClueNumbers);
	if ($$props.isDirectionFocused === void 0 && $$bindings.isDirectionFocused && isDirectionFocused !== void 0) $$bindings.isDirectionFocused(isDirectionFocused);
	if ($$props.onClueFocus === void 0 && $$bindings.onClueFocus && onClueFocus !== void 0) $$bindings.onClueFocus(onClueFocus);
	if ($$props.isDisableHighlight === void 0 && $$bindings.isDisableHighlight && isDisableHighlight !== void 0) $$bindings.isDisableHighlight(isDisableHighlight);
	$$result.css.add(css$4);

	return `<p class="${"svelte-16s2wyn"}">${escape(direction)}</p>
<div class="${"list svelte-16s2wyn"}"><ul class="${"svelte-16s2wyn"}">${each(clues, clue => `${validate_component(Clue, "Clue").$$render(
		$$result,
		{
			clue: clue.clue,
			number: clue.number,
			custom: clue.custom,
			isFilled: clue.isFilled,
			isNumberFocused: focusedClueNumbers[direction] === clue.number,
			isDirectionFocused,
			isDisableHighlight,
			onFocus: () => onClueFocus(clue)
		},
		{},
		{}
	)}`)}</ul>
</div>`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/ClueBar.svelte generated by Svelte v3.29.0 */

const css$5 = {
	code: ".bar.svelte-irjjhy{width:100%;display:flex;justify-content:space-between;background-color:var(--secondary-highlight-color);align-items:center}p.svelte-irjjhy{padding:0 1em;line-height:1.325;font-family:var(--font)}button.svelte-irjjhy{cursor:pointer;font-size:1em;border:none;line-height:1;color:var(--main-color);background-color:transparent}",
	map: "{\"version\":3,\"file\":\"ClueBar.svelte\",\"sources\":[\"ClueBar.svelte\"],\"sourcesContent\":[\"<script>\\n  import { createEventDispatcher } from \\\"svelte\\\";\\n  const dispatch = createEventDispatcher();\\n\\n  export let currentClue = {};\\n  $: clue = currentClue[\\\"clue\\\"];\\n  $: custom = currentClue[\\\"custom\\\"] || \\\"\\\";\\n</script>\\n\\n<div class=\\\"bar {custom}\\\">\\n  <button on:click=\\\"{() => dispatch('nextClue', currentClue.index - 1)}\\\">\\n    <svg\\n      width=\\\"24\\\"\\n      height=\\\"24\\\"\\n      viewBox=\\\"0 0 24 24\\\"\\n      fill=\\\"none\\\"\\n      stroke=\\\"currentColor\\\"\\n      stroke-width=\\\"2\\\"\\n      stroke-linecap=\\\"round\\\"\\n      stroke-linejoin=\\\"round\\\"\\n      class=\\\"feather feather-chevron-left\\\">\\n      <polyline points=\\\"15 18 9 12 15 6\\\"></polyline>\\n    </svg>\\n  </button>\\n  <p>{clue}</p>\\n  <button on:click=\\\"{() => dispatch('nextClue', currentClue.index + 1)}\\\">\\n    <svg\\n      width=\\\"24\\\"\\n      height=\\\"24\\\"\\n      viewBox=\\\"0 0 24 24\\\"\\n      fill=\\\"none\\\"\\n      stroke=\\\"currentColor\\\"\\n      stroke-width=\\\"2\\\"\\n      stroke-linecap=\\\"round\\\"\\n      stroke-linejoin=\\\"round\\\"\\n      class=\\\"feather feather-chevron-right\\\">\\n      <polyline points=\\\"9 18 15 12 9 6\\\"></polyline>\\n    </svg>\\n  </button>\\n</div>\\n\\n<style>\\n  .bar {\\n    width: 100%;\\n    display: flex;\\n    justify-content: space-between;\\n    background-color: var(--secondary-highlight-color);\\n    align-items: center;\\n  }\\n\\n  p {\\n    padding: 0 1em;\\n    line-height: 1.325;\\n    font-family: var(--font);\\n  }\\n\\n  button {\\n    cursor: pointer;\\n    font-size: 1em;\\n    border: none;\\n    line-height: 1;\\n    color: var(--main-color);\\n    background-color: transparent;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AA0CE,IAAI,cAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,gBAAgB,CAAE,IAAI,2BAA2B,CAAC,CAClD,WAAW,CAAE,MAAM,AACrB,CAAC,AAED,CAAC,cAAC,CAAC,AACD,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,WAAW,CAAE,KAAK,CAClB,WAAW,CAAE,IAAI,MAAM,CAAC,AAC1B,CAAC,AAED,MAAM,cAAC,CAAC,AACN,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,GAAG,CACd,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,CAAC,CACd,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,gBAAgB,CAAE,WAAW,AAC/B,CAAC\"}"
};

const ClueBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	const dispatch = createEventDispatcher();
	let { currentClue = {} } = $$props;
	if ($$props.currentClue === void 0 && $$bindings.currentClue && currentClue !== void 0) $$bindings.currentClue(currentClue);
	$$result.css.add(css$5);
	let clue;
	let custom;
	clue = currentClue["clue"];
	custom = currentClue["custom"] || "";

	return `<div class="${"bar " + escape(custom) + " svelte-irjjhy"}"><button class="${"svelte-irjjhy"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" stroke="${"currentColor"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"feather feather-chevron-left"}"><polyline points="${"15 18 9 12 15 6"}"></polyline></svg></button>
  <p class="${"svelte-irjjhy"}">${escape(clue)}</p>
  <button class="${"svelte-irjjhy"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" stroke="${"currentColor"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"feather feather-chevron-right"}"><polyline points="${"9 18 15 12 9 6"}"></polyline></svg></button>
</div>`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Clues.svelte generated by Svelte v3.29.0 */

const css$6 = {
	code: "section.svelte-fisq29.svelte-fisq29{position:sticky;top:1em;flex:0 1 16em;height:fit-content;margin:0;margin-right:1em}section.is-loaded.stacked.svelte-fisq29.svelte-fisq29{position:static;height:auto;top:auto;display:block;margin:1em 0;flex:auto}.clues--stacked.svelte-fisq29.svelte-fisq29{margin:0;display:none}.is-loaded.stacked.svelte-fisq29 .clues--stacked.svelte-fisq29{display:block}.is-loaded.stacked.svelte-fisq29 .clues--list.svelte-fisq29{display:none}@media only screen and (max-width: 720px){section.svelte-fisq29.svelte-fisq29:not(.is-loaded){position:static;height:auto;top:auto;display:block;margin:1em 0;flex:auto}.clues--stacked.svelte-fisq29.svelte-fisq29:not(.is-loaded){display:block}.clues--list.svelte-fisq29.svelte-fisq29:not(.is-loaded){display:none}}",
	map: "{\"version\":3,\"file\":\"Clues.svelte\",\"sources\":[\"Clues.svelte\"],\"sourcesContent\":[\"<script>\\n  import ClueList from \\\"./ClueList.svelte\\\";\\n  import ClueBar from \\\"./ClueBar.svelte\\\";\\n\\n  export let clues;\\n  export let cellIndexMap;\\n  export let focusedDirection;\\n  export let focusedCellIndex;\\n  export let focusedCell;\\n  export let stacked;\\n  export let isDisableHighlight;\\n  export let isLoaded;\\n\\n  $: focusedClueNumbers = focusedCell.clueNumbers || {};\\n  $: currentClue =\\n    clues.find(\\n      c =>\\n        c.direction === focusedDirection &&\\n        c.number === focusedClueNumbers[focusedDirection]\\n    ) || {};\\n\\n  function onClueFocus({ direction, id }) {\\n    focusedDirection = direction;\\n    focusedCellIndex = cellIndexMap[id] || 0;\\n  }\\n\\n  function onNextClue({ detail }) {\\n    let next = detail;\\n    if (next < 0) next = clues.length - 1;\\n    else if (next > clues.length - 1) next = 0;\\n    const { direction, id } = clues[next];\\n    onClueFocus({ direction, id });\\n  }\\n</script>\\n\\n<section class=\\\"clues\\\" class:stacked class:is-loaded=\\\"{isLoaded}\\\">\\n  <div class=\\\"clues--stacked\\\">\\n    <ClueBar {currentClue} on:nextClue=\\\"{onNextClue}\\\" />\\n  </div>\\n\\n  <div class=\\\"clues--list\\\">\\n    {#each ['across', 'down'] as direction}\\n      <ClueList\\n        {direction}\\n        {focusedClueNumbers}\\n        clues=\\\"{clues.filter(d => d.direction === direction)}\\\"\\n        isDirectionFocused=\\\"{focusedDirection === direction}\\\"\\n        {isDisableHighlight}\\n        {onClueFocus} />\\n    {/each}\\n  </div>\\n</section>\\n\\n<style>\\n  section {\\n    position: sticky;\\n    top: 1em;\\n    flex: 0 1 16em;\\n    height: fit-content;\\n    margin: 0;\\n    margin-right: 1em;\\n  }\\n\\n  section.is-loaded.stacked {\\n    position: static;\\n    height: auto;\\n    top: auto;\\n    display: block;\\n    margin: 1em 0;\\n    flex: auto;\\n  }\\n\\n  .clues--stacked {\\n    margin: 0;\\n    display: none;\\n  }\\n\\n  .is-loaded.stacked .clues--stacked {\\n    display: block;\\n  }\\n\\n  .is-loaded.stacked .clues--list {\\n    display: none;\\n  }\\n\\n  @media only screen and (max-width: 720px) {\\n    section:not(.is-loaded) {\\n      position: static;\\n      height: auto;\\n      top: auto;\\n      display: block;\\n      margin: 1em 0;\\n      flex: auto;\\n    }\\n\\n    .clues--stacked:not(.is-loaded) {\\n      display: block;\\n    }\\n\\n    .clues--list:not(.is-loaded) {\\n      display: none;\\n    }\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAsDE,OAAO,4BAAC,CAAC,AACP,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,MAAM,CAAE,WAAW,CACnB,MAAM,CAAE,CAAC,CACT,YAAY,CAAE,GAAG,AACnB,CAAC,AAED,OAAO,UAAU,QAAQ,4BAAC,CAAC,AACzB,QAAQ,CAAE,MAAM,CAChB,MAAM,CAAE,IAAI,CACZ,GAAG,CAAE,IAAI,CACT,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,IAAI,CAAE,IAAI,AACZ,CAAC,AAED,eAAe,4BAAC,CAAC,AACf,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,IAAI,AACf,CAAC,AAED,UAAU,sBAAQ,CAAC,eAAe,cAAC,CAAC,AAClC,OAAO,CAAE,KAAK,AAChB,CAAC,AAED,UAAU,sBAAQ,CAAC,YAAY,cAAC,CAAC,AAC/B,OAAO,CAAE,IAAI,AACf,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,mCAAO,KAAK,UAAU,CAAC,AAAC,CAAC,AACvB,QAAQ,CAAE,MAAM,CAChB,MAAM,CAAE,IAAI,CACZ,GAAG,CAAE,IAAI,CACT,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,IAAI,CAAE,IAAI,AACZ,CAAC,AAED,2CAAe,KAAK,UAAU,CAAC,AAAC,CAAC,AAC/B,OAAO,CAAE,KAAK,AAChB,CAAC,AAED,wCAAY,KAAK,UAAU,CAAC,AAAC,CAAC,AAC5B,OAAO,CAAE,IAAI,AACf,CAAC,AACH,CAAC\"}"
};

const Clues = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { clues } = $$props;
	let { cellIndexMap } = $$props;
	let { focusedDirection } = $$props;
	let { focusedCellIndex } = $$props;
	let { focusedCell } = $$props;
	let { stacked } = $$props;
	let { isDisableHighlight } = $$props;
	let { isLoaded } = $$props;

	function onClueFocus({ direction, id }) {
		focusedDirection = direction;
		focusedCellIndex = cellIndexMap[id] || 0;
	}

	if ($$props.clues === void 0 && $$bindings.clues && clues !== void 0) $$bindings.clues(clues);
	if ($$props.cellIndexMap === void 0 && $$bindings.cellIndexMap && cellIndexMap !== void 0) $$bindings.cellIndexMap(cellIndexMap);
	if ($$props.focusedDirection === void 0 && $$bindings.focusedDirection && focusedDirection !== void 0) $$bindings.focusedDirection(focusedDirection);
	if ($$props.focusedCellIndex === void 0 && $$bindings.focusedCellIndex && focusedCellIndex !== void 0) $$bindings.focusedCellIndex(focusedCellIndex);
	if ($$props.focusedCell === void 0 && $$bindings.focusedCell && focusedCell !== void 0) $$bindings.focusedCell(focusedCell);
	if ($$props.stacked === void 0 && $$bindings.stacked && stacked !== void 0) $$bindings.stacked(stacked);
	if ($$props.isDisableHighlight === void 0 && $$bindings.isDisableHighlight && isDisableHighlight !== void 0) $$bindings.isDisableHighlight(isDisableHighlight);
	if ($$props.isLoaded === void 0 && $$bindings.isLoaded && isLoaded !== void 0) $$bindings.isLoaded(isLoaded);
	$$result.css.add(css$6);
	let focusedClueNumbers;
	let currentClue;
	focusedClueNumbers = focusedCell.clueNumbers || {};
	currentClue = clues.find(c => c.direction === focusedDirection && c.number === focusedClueNumbers[focusedDirection]) || {};

	return `<section class="${[
		"clues svelte-fisq29",
		(stacked ? "stacked" : "") + " " + (isLoaded ? "is-loaded" : "")
	].join(" ").trim()}"><div class="${"clues--stacked svelte-fisq29"}">${validate_component(ClueBar, "ClueBar").$$render($$result, { currentClue }, {}, {})}</div>

  <div class="${"clues--list svelte-fisq29"}">${each(["across", "down"], direction => `${validate_component(ClueList, "ClueList").$$render(
		$$result,
		{
			direction,
			focusedClueNumbers,
			clues: clues.filter(d => d.direction === direction),
			isDirectionFocused: focusedDirection === direction,
			isDisableHighlight,
			onClueFocus
		},
		{},
		{}
	)}`)}</div>
</section>`;
});

function quadIn(t) {
    return t * t;
}

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Confetti.svelte generated by Svelte v3.29.0 */

const css$7 = {
	code: ".confetti.svelte-15wt7c8{width:2em;position:absolute;stroke-linecap:round;stroke-linejoin:round;fill-rule:evenodd;clip-rule:evenodd;pointer-events:none;overflow:visible;transform:translate(-50%, -50%)}@keyframes svelte-15wt7c8-pop{0%{transform:rotate(var(--rotation)) scale(1) translate(0em, 0em)}100%{transform:rotate(calc(var(--rotation) + 60deg)) scale(0)\n        translate(9em, 9em);fill:white}}g.svelte-15wt7c8{transition:all 0.5s ease-out;transform:rotate(var(--rotation)) scale(0) translate(0, 0);animation:svelte-15wt7c8-pop 2s ease-out;animation-iteration-count:infinite}",
	map: "{\"version\":3,\"file\":\"Confetti.svelte\",\"sources\":[\"Confetti.svelte\"],\"sourcesContent\":[\"<script>\\n  import { quadIn } from \\\"svelte/easing\\\";\\n\\n  export let numberOfElements = 50;\\n  export let durationInSeconds = 2;\\n  export let colors = [\\n    \\\"#fff\\\",\\n    \\\"#c7ecee\\\",\\n    \\\"#778beb\\\",\\n    \\\"#f7d794\\\",\\n    \\\"#63cdda\\\",\\n    \\\"#cf6a87\\\",\\n    \\\"#e77f67\\\",\\n    \\\"#786fa6\\\",\\n    \\\"#FDA7DF\\\",\\n    \\\"#4b7bec\\\",\\n    \\\"#475c83\\\",\\n  ];\\n\\n  const pickFrom = (arr) => arr[Math.round(Math.random() * arr.length)];\\n  const randomNumber = (min, max) => Math.random() * (max - min) + min;\\n  const getManyOf = (str) => new Array(30).fill(0).map(() => str);\\n\\n  const elementOptions = [\\n    ...getManyOf(`<circle r=\\\"3\\\" />`),\\n    ...getManyOf(\\n      `<path d=\\\"M3.83733 4.73234C4.38961 4.73234 4.83733 4.28463 4.83733 3.73234C4.83733 3.18006 4.38961 2.73234 3.83733 2.73234C3.28505 2.73234 2.83733 3.18006 2.83733 3.73234C2.83733 4.28463 3.28505 4.73234 3.83733 4.73234ZM3.83733 6.73234C5.49418 6.73234 6.83733 5.38919 6.83733 3.73234C6.83733 2.07549 5.49418 0.732341 3.83733 0.732341C2.18048 0.732341 0.83733 2.07549 0.83733 3.73234C0.83733 5.38919 2.18048 6.73234 3.83733 6.73234Z\\\" />`\\n    ),\\n    ...getManyOf(\\n      `<path d=\\\"M4.29742 2.26041C3.86864 2.1688 3.20695 2.21855 2.13614 3.0038C1.69078 3.33041 1.06498 3.23413 0.738375 2.78876C0.411774 2.3434 0.508051 1.7176 0.953417 1.39099C2.32237 0.387097 3.55827 0.0573281 4.71534 0.304565C5.80081 0.536504 6.61625 1.24716 7.20541 1.78276C7.28295 1.85326 7.35618 1.92051 7.4263 1.9849C7.64841 2.18888 7.83929 2.36418 8.03729 2.52315C8.29108 2.72692 8.48631 2.8439 8.64952 2.90181C8.7915 2.95219 8.91895 2.96216 9.07414 2.92095C9.24752 2.8749 9.5134 2.7484 9.88467 2.42214C10.2995 2.05757 10.9314 2.09833 11.2959 2.51319C11.6605 2.92805 11.6198 3.5599 11.2049 3.92447C10.6816 4.38435 10.1478 4.70514 9.58752 4.85394C9.00909 5.00756 8.469 4.95993 7.9807 4.78667C7.51364 4.62093 7.11587 4.34823 6.78514 4.08268C6.53001 3.87783 6.27248 3.64113 6.04114 3.4285C5.97868 3.37109 5.91814 3.31544 5.86006 3.26264C5.25645 2.7139 4.79779 2.36733 4.29742 2.26041Z\\\" />`\\n    ),\\n    ...getManyOf(`<rect width=\\\"4\\\" height=\\\"4\\\" x=\\\"-2\\\" y=\\\"-2\\\" />`),\\n    `<path d=\\\"M -5 5 L 0 -5 L 5 5 Z\\\" />`,\\n    ...\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n      .split(\\\"\\\")\\n      .map((letter) => `<text style=\\\"font-weight: 700\\\">${letter}</text>`),\\n  ];\\n\\n  const allElements = new Array(numberOfElements)\\n    .fill(0)\\n    .map((_, i) => [pickFrom(elementOptions), pickFrom(colors), Math.random()]);\\n</script>\\n\\n<svg class=\\\"confetti\\\" viewBox=\\\"-10 -10 10 10\\\">\\n  {#each allElements as [element, color, scale], i}\\n    <g style=\\\"transform: scale({scale})\\\">\\n      <g\\n        fill=\\\"{color}\\\"\\n        style=\\\"{[`--rotation: ${Math.random() * 360}deg`, `animation-delay: ${quadIn(i / numberOfElements)}s`, `animation-duration: ${durationInSeconds * randomNumber(0.7, 1)}s`].join(';')}\\\">\\n        {@html element}\\n      </g>\\n    </g>\\n  {/each}\\n</svg>\\n\\n<style>\\n  .confetti {\\n    width: 2em;\\n    position: absolute;\\n    stroke-linecap: round;\\n    stroke-linejoin: round;\\n    fill-rule: evenodd;\\n    clip-rule: evenodd;\\n    pointer-events: none;\\n    overflow: visible;\\n    transform: translate(-50%, -50%);\\n  }\\n  @keyframes pop {\\n    0% {\\n      transform: rotate(var(--rotation)) scale(1) translate(0em, 0em);\\n    }\\n    100% {\\n      transform: rotate(calc(var(--rotation) + 60deg)) scale(0)\\n        translate(9em, 9em);\\n      fill: white;\\n    }\\n  }\\n  g {\\n    transition: all 0.5s ease-out;\\n    transform: rotate(var(--rotation)) scale(0) translate(0, 0);\\n    animation: pop 2s ease-out;\\n    animation-iteration-count: infinite;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAwDE,SAAS,eAAC,CAAC,AACT,KAAK,CAAE,GAAG,CACV,QAAQ,CAAE,QAAQ,CAClB,cAAc,CAAE,KAAK,CACrB,eAAe,CAAE,KAAK,CACtB,SAAS,CAAE,OAAO,CAClB,SAAS,CAAE,OAAO,CAClB,cAAc,CAAE,IAAI,CACpB,QAAQ,CAAE,OAAO,CACjB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,AAClC,CAAC,AACD,WAAW,kBAAI,CAAC,AACd,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,OAAO,IAAI,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,AACjE,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACvD,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CACrB,IAAI,CAAE,KAAK,AACb,CAAC,AACH,CAAC,AACD,CAAC,eAAC,CAAC,AACD,UAAU,CAAE,GAAG,CAAC,IAAI,CAAC,QAAQ,CAC7B,SAAS,CAAE,OAAO,IAAI,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3D,SAAS,CAAE,kBAAG,CAAC,EAAE,CAAC,QAAQ,CAC1B,yBAAyB,CAAE,QAAQ,AACrC,CAAC\"}"
};

const Confetti = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { numberOfElements = 50 } = $$props;
	let { durationInSeconds = 2 } = $$props;

	let { colors = [
		"#fff",
		"#c7ecee",
		"#778beb",
		"#f7d794",
		"#63cdda",
		"#cf6a87",
		"#e77f67",
		"#786fa6",
		"#FDA7DF",
		"#4b7bec",
		"#475c83"
	] } = $$props;

	const pickFrom = arr => arr[Math.round(Math.random() * arr.length)];
	const randomNumber = (min, max) => Math.random() * (max - min) + min;
	const getManyOf = str => new Array(30).fill(0).map(() => str);

	const elementOptions = [
		...getManyOf(`<circle r="3" />`),
		...getManyOf(`<path d="M3.83733 4.73234C4.38961 4.73234 4.83733 4.28463 4.83733 3.73234C4.83733 3.18006 4.38961 2.73234 3.83733 2.73234C3.28505 2.73234 2.83733 3.18006 2.83733 3.73234C2.83733 4.28463 3.28505 4.73234 3.83733 4.73234ZM3.83733 6.73234C5.49418 6.73234 6.83733 5.38919 6.83733 3.73234C6.83733 2.07549 5.49418 0.732341 3.83733 0.732341C2.18048 0.732341 0.83733 2.07549 0.83733 3.73234C0.83733 5.38919 2.18048 6.73234 3.83733 6.73234Z" />`),
		...getManyOf(`<path d="M4.29742 2.26041C3.86864 2.1688 3.20695 2.21855 2.13614 3.0038C1.69078 3.33041 1.06498 3.23413 0.738375 2.78876C0.411774 2.3434 0.508051 1.7176 0.953417 1.39099C2.32237 0.387097 3.55827 0.0573281 4.71534 0.304565C5.80081 0.536504 6.61625 1.24716 7.20541 1.78276C7.28295 1.85326 7.35618 1.92051 7.4263 1.9849C7.64841 2.18888 7.83929 2.36418 8.03729 2.52315C8.29108 2.72692 8.48631 2.8439 8.64952 2.90181C8.7915 2.95219 8.91895 2.96216 9.07414 2.92095C9.24752 2.8749 9.5134 2.7484 9.88467 2.42214C10.2995 2.05757 10.9314 2.09833 11.2959 2.51319C11.6605 2.92805 11.6198 3.5599 11.2049 3.92447C10.6816 4.38435 10.1478 4.70514 9.58752 4.85394C9.00909 5.00756 8.469 4.95993 7.9807 4.78667C7.51364 4.62093 7.11587 4.34823 6.78514 4.08268C6.53001 3.87783 6.27248 3.64113 6.04114 3.4285C5.97868 3.37109 5.91814 3.31544 5.86006 3.26264C5.25645 2.7139 4.79779 2.36733 4.29742 2.26041Z" />`),
		...getManyOf(`<rect width="4" height="4" x="-2" y="-2" />`),
		`<path d="M -5 5 L 0 -5 L 5 5 Z" />`,
		...("ABCDEFGHIJKLMNOPQRSTUVWXYZ").split("").map(letter => `<text style="font-weight: 700">${letter}</text>`)
	];

	const allElements = new Array(numberOfElements).fill(0).map((_, i) => [pickFrom(elementOptions), pickFrom(colors), Math.random()]);
	if ($$props.numberOfElements === void 0 && $$bindings.numberOfElements && numberOfElements !== void 0) $$bindings.numberOfElements(numberOfElements);
	if ($$props.durationInSeconds === void 0 && $$bindings.durationInSeconds && durationInSeconds !== void 0) $$bindings.durationInSeconds(durationInSeconds);
	if ($$props.colors === void 0 && $$bindings.colors && colors !== void 0) $$bindings.colors(colors);
	$$result.css.add(css$7);

	return `<svg class="${"confetti svelte-15wt7c8"}" viewBox="${"-10 -10 10 10"}">${each(allElements, ([element, color, scale], i) => `<g style="${"transform: scale(" + escape(scale) + ")"}" class="${"svelte-15wt7c8"}"><g${add_attribute("fill", color, 0)}${add_attribute(
		"style",
		[
			`--rotation: ${Math.random() * 360}deg`,
			`animation-delay: ${quadIn(i / numberOfElements)}s`,
			`animation-duration: ${durationInSeconds * randomNumber(0.7, 1)}s`
		].join(";"),
		0
	)} class="${"svelte-15wt7c8"}">${element}</g></g>`)}</svg>`;
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/CompletedMessage.svelte generated by Svelte v3.29.0 */

const css$8 = {
	code: ".completed.svelte-hm3hg2{position:absolute;top:min(50%, 15em);left:50%;background-color:var(--bg-color);transform:translate(-50%, -50%);border-radius:4px;z-index:100;box-shadow:0 4px 8px 4px rgba(0, 0, 0, 0.2);font-family:var(--font)}.curtain.svelte-hm3hg2{position:absolute;top:0;right:-2px;bottom:0;left:0;background-color:var(--bg-color);opacity:0.9;cursor:pointer;z-index:1}button.svelte-hm3hg2{cursor:pointer;margin-left:1em;font-size:1em;font-family:var(--font);background-color:var(--accent-color);border-radius:4px;color:var(--main-color);padding:0.75em;border:none;font-weight:400;transition:background-color 150ms}button.svelte-hm3hg2:hover{background-color:var(--secondary-highlight-color)}.content.svelte-hm3hg2{position:relative;display:flex;flex-direction:column;align-items:center;padding:2em}.message.svelte-hm3hg2{margin-bottom:1em}.confetti.svelte-hm3hg2{position:absolute;top:30%;left:50%;transform:translate(-50%, -50%)}",
	map: "{\"version\":3,\"file\":\"CompletedMessage.svelte\",\"sources\":[\"CompletedMessage.svelte\"],\"sourcesContent\":[\"<script>\\n  import { fade } from \\\"svelte/transition\\\";\\n  import Confetti from \\\"./Confetti.svelte\\\";\\n\\n  export let showConfetti = true;\\n\\n  let isOpen = true;\\n</script>\\n\\n{#if isOpen}\\n  <div class=\\\"completed\\\" transition:fade=\\\"{{ y: 20 }}\\\">\\n    <div class=\\\"content\\\">\\n      <div class=\\\"message\\\">\\n        <slot />\\n      </div>\\n\\n      <button on:click=\\\"{() => (isOpen = false)}\\\">View puzzle</button>\\n    </div>\\n\\n    {#if showConfetti}\\n      <div class=\\\"confetti\\\">\\n        <Confetti />\\n      </div>\\n    {/if}\\n  </div>\\n  <div\\n    class=\\\"curtain\\\"\\n    transition:fade=\\\"{{ duration: 250 }}\\\"\\n    on:click=\\\"{() => (isOpen = false)}\\\"></div>\\n{/if}\\n\\n<style>\\n  .completed {\\n    position: absolute;\\n    top: min(50%, 15em);\\n    left: 50%;\\n    background-color: var(--bg-color);\\n    transform: translate(-50%, -50%);\\n    border-radius: 4px;\\n    z-index: 100;\\n    box-shadow: 0 4px 8px 4px rgba(0, 0, 0, 0.2);\\n    font-family: var(--font);\\n  }\\n\\n  .curtain {\\n    position: absolute;\\n    top: 0;\\n    right: -2px;\\n    bottom: 0;\\n    left: 0;\\n    background-color: var(--bg-color);\\n    opacity: 0.9;\\n    cursor: pointer;\\n    z-index: 1;\\n  }\\n\\n  button {\\n    cursor: pointer;\\n    margin-left: 1em;\\n    font-size: 1em;\\n    font-family: var(--font);\\n    background-color: var(--accent-color);\\n    border-radius: 4px;\\n    color: var(--main-color);\\n    padding: 0.75em;\\n    border: none;\\n    font-weight: 400;\\n    transition: background-color 150ms;\\n  }\\n\\n  button:hover {\\n    background-color: var(--secondary-highlight-color);\\n  }\\n\\n  .content {\\n    position: relative;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    padding: 2em;\\n  }\\n\\n  .message {\\n    margin-bottom: 1em;\\n  }\\n\\n  .confetti {\\n    position: absolute;\\n    top: 30%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAgCE,UAAU,cAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CACnB,IAAI,CAAE,GAAG,CACT,gBAAgB,CAAE,IAAI,UAAU,CAAC,CACjC,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC5C,WAAW,CAAE,IAAI,MAAM,CAAC,AAC1B,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,CACP,gBAAgB,CAAE,IAAI,UAAU,CAAC,CACjC,OAAO,CAAE,GAAG,CACZ,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,MAAM,cAAC,CAAC,AACN,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,IAAI,MAAM,CAAC,CACxB,gBAAgB,CAAE,IAAI,cAAc,CAAC,CACrC,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,OAAO,CAAE,MAAM,CACf,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,gBAAgB,CAAC,KAAK,AACpC,CAAC,AAED,oBAAM,MAAM,AAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,2BAA2B,CAAC,AACpD,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,GAAG,AACd,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,aAAa,CAAE,GAAG,AACpB,CAAC,AAED,SAAS,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,CACT,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,AAClC,CAAC\"}"
};

const CompletedMessage = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { showConfetti = true } = $$props;
	if ($$props.showConfetti === void 0 && $$bindings.showConfetti && showConfetti !== void 0) $$bindings.showConfetti(showConfetti);
	$$result.css.add(css$8);

	return `${ `<div class="${"completed svelte-hm3hg2"}"><div class="${"content svelte-hm3hg2"}"><div class="${"message svelte-hm3hg2"}">${slots.default ? slots.default({}) : ``}</div>

      <button class="${"svelte-hm3hg2"}">View puzzle</button></div>

    ${showConfetti
		? `<div class="${"confetti svelte-hm3hg2"}">${validate_component(Confetti, "Confetti").$$render($$result, {}, {}, {})}</div>`
		: ``}</div>
  <div class="${"curtain svelte-hm3hg2"}"></div>`
	}`;
});

function createClues(data) {
	// determine if 0 or 1 based
	const minX = Math.min(...data.map(d => d.x));
	const minY = Math.min(...data.map(d => d.y));
	const adjust = Math.min(minX, minY);

	
	const withAdjust = data.map(d => ({
		...d,
		x: d.x - adjust,
		y: d.y - adjust
	}));

  const withId = withAdjust.map((d, i) => ({
		...d,
    id: `${d.x}-${d.y}`,
  }));
	
  // sort asc by start position of clue so we have proper clue ordering
  withId.sort((a, b) => a.y - b.y || a.x - b.x);

  // create a lookup to store clue number (and reuse if same start pos)
  let lookup = {};
  let currentNumber = 1;

  const withNumber = withId.map((d) => {
    let number;
    if (lookup[d.id]) number = lookup[d.id];
    else {
      lookup[d.id] = number = currentNumber;
      currentNumber += 1;
    }
    return {
      ...d,
      number,
    };
  });


	// create cells for each letter
	const withCells = withNumber.map(d => {
		const chars = d.answer.split("");
    const cells = chars.map((answer, i) => {
      const x = d.x + (d.direction === "across" ? i : 0);
      const y = d.y + (d.direction === "down" ? i : 0);
      const number = i === 0 ? d.number : "";
      const clueNumbers = { [d.direction]: d.number };
      const id = `${x}-${y}`;
      const value = "";
      const custom = d.custom || "";
      return {
        id,
        number,
        clueNumbers,
        x,
        y,
        value,
        answer: answer.toUpperCase(),
        custom,
      };
    });
		return {
			...d,
			cells
		}
	});

	withCells.sort((a, b) => {
		if (a.direction < b.direction) return -1;
		else if (a.direction > b.direction) return 1;
		return a.number - b.number;
	});
	const withIndex = withCells.map((d, i) => ({
		...d,
		index: i
	}));
	return withIndex;
}

function createCells(data) {
  const cells = [].concat(...data.map(d => d.cells));
  let dict = {};

  // sort so that ones with number values come first and dedupe
  cells.sort((a, b) => a.y - b.y || a.x - b.x || b.number - a.number);
  cells.forEach((d) => {
    if (!dict[d.id]) {
      dict[d.id] = d;
    } else {
      // consolidate clue numbers for across & down
      dict[d.id].clueNumbers = {
        ...d.clueNumbers,
        ...dict[d.id].clueNumbers,
      };
      // consolidate custom classes
      if (dict[d.id].custom !== d.custom)
        dict[d.id].custom = `${dict[d.id].custom} ${d.custom}`;
    }
  });

  const unique = Object.keys(dict).map((d) => dict[d]);
  unique.sort((a, b) => a.y - b.y || a.x - b.x);
  // add index
  const output = unique.map((d, i) => ({ ...d, index: i }));
  return output;
}

function validateClues(data) {
	const props = [
    {
      prop: "clue",
      type: "string",
    },
    {
      prop: "answer",
      type: "string",
    },
    {
      prop: "x",
      type: "number",
    },
    {
      prop: "y",
      type: "number",
    }
  ];

	// only store if they fail
	let failedProp = false;
  data.forEach(d => !!props.map(p => {
		const f = typeof d[p.prop] !== p.type;
		if (f) {
			failedProp = true;
			console.error(`"${p.prop}" is not a ${p.type}\n`, d);
		}
	}));

	let failedCell = false;
	const cells = [].concat(...data.map(d => d.cells));
	
	let dict = {};
	cells.forEach((d) => {
    if (!dict[d.id]) {
      dict[d.id] = d.answer;
    } else {
			if (dict[d.id] !== d.answer) {
				failedCell = true;
				console.error(`cell "${d.id}" has two different values\n`, `${dict[d.id]} and ${d.answer}`);
			}
		}
  });

	return !failedProp && !failedCell;
}

function fromPairs(arr) {
  let res = {};
  arr.forEach((d) => {
    res[d[0]] = d[1];
  });
  return res;
}

var classic = {
	"font": "sans-serif",
	"primary-highlight-color": "#ffda00",
	"secondary-highlight-color": "#a7d8ff",
	"main-color": "#1a1a1a",
	"bg-color": "#fff",
	"accent-color": "#efefef",
	"scrollbar-color": "#cdcdcd",
	"order": "row"
};

var dark = {
	"primary-highlight-color": "#066",
	"secondary-highlight-color": "#003d3d",
	"main-color": "#efefef",
	"bg-color": "#1a1a1a",
	"accent-color": "#3a3a3a"
};

var citrus = {
	"primary-highlight-color": "#ff957d",
	"secondary-highlight-color": "#ffdfd5",
	"main-color": "#184444",
	"accent-color": "#ebf3f3"
};

var amelia = {
	"font": "sans-serif",
	"primary-highlight-color": "#d7cefd",
	"secondary-highlight-color": "#9980fa",
	"main-color": "#353b48",
	"bg-color": "#fff",
	"accent-color": "#efefef",
	"scrollbar-color": "#9980fa",
};

const themes = { classic, dark, citrus, amelia };
const defaultTheme = themes["classic"];

Object.keys(themes).forEach((t) => {
	themes[t] = Object.keys(defaultTheme)
		.map((d) => `--${d}: var(--xd-${d}, ${themes[t][d] || defaultTheme[d]})`)
		.join(";");
});

/* Users/graeme.hoffman/Documents/WORK/crossword/src/Crossword.svelte generated by Svelte v3.29.0 */

const css$9 = {
	code: "article.svelte-186p9qm{position:relative;background-color:transparent;font-size:16px}.play.svelte-186p9qm{display:flex;flex-direction:var(--order, row)}.play.is-loaded.stacked.svelte-186p9qm{flex-direction:column}h3.svelte-186p9qm{margin:0;margin-bottom:0.5em}@media only screen and (max-width: 720px){.play.svelte-186p9qm:not(.is-loaded){flex-direction:column}}",
	map: "{\"version\":3,\"file\":\"Crossword.svelte\",\"sources\":[\"Crossword.svelte\"],\"sourcesContent\":[\"<script>\\n  import { onMount, createEventDispatcher } from \\\"svelte\\\";\\n  import Toolbar from \\\"./Toolbar.svelte\\\";\\n  import Puzzle from \\\"./Puzzle.svelte\\\";\\n  import Clues from \\\"./Clues.svelte\\\";\\n  import CompletedMessage from \\\"./CompletedMessage.svelte\\\";\\n  import createClues from \\\"./helpers/createClues.js\\\";\\n  import createCells from \\\"./helpers/createCells.js\\\";\\n  import validateClues from \\\"./helpers/validateClues.js\\\";\\n  import { fromPairs } from \\\"./helpers/utils.js\\\";\\n  import themeStyles from \\\"./helpers/themeStyles.js\\\";\\n\\n  export let data = [];\\n  export let state = {}; // {clues: }\\n  export let actions = [\\\"clear\\\", \\\"reveal\\\", \\\"check\\\", \\\"uncheck\\\"];\\n  export let theme = \\\"classic\\\";\\n  export let revealDuration = 1000;\\n  export let breakpoint = 720;\\n  export let revealed = false;\\n  export let disableHighlight = false;\\n  export let showCompleteMessage = true;\\n  export let showConfetti = true;\\n  export let showKeyboard;\\n  export let keyboardStyle = \\\"outline\\\";\\n\\n  let width = 0;\\n  let focusedDirection = \\\"across\\\";\\n  let focusedCellIndex = 0;\\n  let isRevealing = false;\\n  let isLoaded = false;\\n  let isChecking = false;\\n  let revealTimeout;\\n  let clueCompletion;\\n\\n  let originalClues = [];\\n  let validated = [];\\n  let clues = [];\\n  let cells = [];\\n\\n  const dispatch = createEventDispatcher();\\n\\n  const onDataUpdate = () => {\\n    console.log('onDataUpdate');\\n    originalClues = createClues(data);\\n    validated = validateClues(originalClues);\\n    clues = originalClues.map((d) => ({ ...d }));\\n    cells = createCells(originalClues);\\n    reset();\\n    if (state && state.cells) {\\n      setState(state);\\n    }\\n  };\\n\\n  $: data, onDataUpdate();\\n  $: focusedCell = cells[focusedCellIndex] || {};\\n  $: cellIndexMap = fromPairs(cells.map((cell) => [cell.id, cell.index]));\\n  $: percentCorrect = cells.filter((d) => d.answer === d.value).length / cells.length;\\n  $: isComplete = percentCorrect == 1;\\n  $: if (isComplete && cells.length > 0) {\\n    onComplete();\\n  };\\n  $: isDisableHighlight = isComplete && disableHighlight;\\n  $: cells, (clues = checkClues());\\n  $: cells, (revealed = !clues.filter((d) => !d.isCorrect).length);\\n  $: stacked = width < breakpoint;\\n  $: inlineStyles = themeStyles[theme];\\n\\n  onMount(() => {\\n    isLoaded = true;\\n  });\\n\\n  function checkClues() {\\n    return clues.map((d) => {\\n      const index = d.index;\\n      const cellChecks = d.cells.map((c) => {\\n        const { value } = cells.find((e) => e.id === c.id);\\n        const hasValue = !!value;\\n        const hasCorrect = value === c.answer;\\n        return { hasValue, hasCorrect };\\n      });\\n      const isCorrect =\\n        cellChecks.filter((c) => c.hasCorrect).length === d.answer.length;\\n      const isFilled =\\n        cellChecks.filter((c) => c.hasValue).length === d.answer.length;\\n      return {\\n        ...d,\\n        isCorrect,\\n        isFilled,\\n      };\\n    });\\n  }\\n\\n  function reset() {\\n    isRevealing = false;\\n    isChecking = false;\\n    focusedCellIndex = 0;\\n    focusedDirection = \\\"across\\\";\\n  }\\n\\n  /**\\n   * Setting previous saved state\\n   * \\n   *   answer: \\\"F\\\"\\n   *   clueNumbers: {down: 1, across: 1}\\n   *   custom: \\\"\\\"\\n   *   id: \\\"2-0\\\"\\n   *   index: 0\\n   *   number: 1\\n   *   value: \\\"F\\\"\\n   *   x: 2\\n   *   y: 0\\n   * \\n   * @param state\\n   */\\n  function setState(state) {\\n    if (state.cells.length) {\\n      cells = cells.map((cell) => {\\n        const currCell = state.cells.find(obj => {\\n          return obj.id === cell.id\\n        });\\n        return {\\n          ...cell,\\n          value: currCell.value\\n        }\\n      });\\n    }\\n  }\\n\\n  function onClear() {\\n    reset();\\n    if (revealTimeout) clearTimeout(revealTimeout);\\n    cells = cells.map((cell) => ({\\n      ...cell,\\n      value: \\\"\\\",\\n    }));\\n  }\\n\\n  function onReveal() {\\n    if (revealed) return true;\\n    reset();\\n    cells = cells.map((cell) => ({\\n      ...cell,\\n      value: cell.answer,\\n    }));\\n    startReveal();\\n  }\\n\\n  function onCheck() {\\n    isChecking = true;\\n  }\\n\\n  function onUncheck() {\\n    isChecking = false;\\n  }\\n\\n  function onCellChange (event) {\\n    dispatch('cellChange', {\\n\\t\\t\\tcells: event.detail.cells\\n\\t\\t});\\n  }\\n\\n  const onComplete = () => {\\n    dispatch('complete', {\\n\\t\\t\\tcellIndexMap: cellIndexMap\\n\\t\\t});\\n  };\\n\\n  function startReveal() {\\n    isRevealing = true;\\n    isChecking = false;\\n    if (revealTimeout) clearTimeout(revealTimeout);\\n    revealTimeout = setTimeout(() => {\\n      isRevealing = false;\\n    }, revealDuration + 250);\\n  }\\n\\n  function onToolbarEvent({ detail }) {\\n    if (detail === \\\"clear\\\") onClear();\\n    else if (detail === \\\"reveal\\\") onReveal();\\n    else if (detail === \\\"check\\\") onCheck();\\n    else if (detail === \\\"uncheck\\\") onUncheck();\\n  }\\n</script>\\n\\n{#if validated}\\n  <article\\n    class=\\\"svelte-crossword\\\"\\n    bind:offsetWidth=\\\"{width}\\\"\\n    style=\\\"{inlineStyles}\\\">\\n    <slot\\n      name=\\\"toolbar\\\"\\n      onClear=\\\"{onClear}\\\"\\n      onReveal=\\\"{onReveal}\\\"\\n      onCheck=\\\"{onCheck}\\\"\\n      onUncheck=\\\"{onUncheck}\\\">\\n      <Toolbar actions=\\\"{actions}\\\" on:event=\\\"{onToolbarEvent}\\\" />\\n    </slot>\\n\\n    <div class=\\\"play\\\" class:stacked class:is-loaded=\\\"{isLoaded}\\\">\\n      <Clues\\n        clues=\\\"{clues}\\\"\\n        cellIndexMap=\\\"{cellIndexMap}\\\"\\n        stacked=\\\"{stacked}\\\"\\n        isDisableHighlight=\\\"{isDisableHighlight}\\\"\\n        isLoaded=\\\"{isLoaded}\\\"\\n        bind:focusedCellIndex\\n        bind:focusedCell\\n        bind:focusedDirection />\\n      <Puzzle\\n        clues=\\\"{clues}\\\"\\n        focusedCell=\\\"{focusedCell}\\\"\\n        isRevealing=\\\"{isRevealing}\\\"\\n        isChecking=\\\"{isChecking}\\\"\\n        isDisableHighlight=\\\"{isDisableHighlight}\\\"\\n        revealDuration=\\\"{revealDuration}\\\"\\n        showKeyboard=\\\"{showKeyboard}\\\"\\n        stacked=\\\"{stacked}\\\"\\n        isLoaded=\\\"{isLoaded}\\\"\\n        keyboardStyle=\\\"{keyboardStyle}\\\"\\n        on:cellChange\\n        bind:cells\\n        bind:focusedCellIndex\\n        bind:focusedDirection />\\n    </div>\\n\\n    {#if isComplete && !isRevealing && showCompleteMessage}\\n      <CompletedMessage showConfetti=\\\"{showConfetti}\\\">\\n        <slot name=\\\"message\\\">\\n          <h3>You solved it!</h3>\\n        </slot>\\n      </CompletedMessage>\\n    {/if}\\n  </article>\\n{/if}\\n\\n<style>\\n  article {\\n    position: relative;\\n    background-color: transparent;\\n    font-size: 16px;\\n  }\\n\\n  .play {\\n    display: flex;\\n    flex-direction: var(--order, row);\\n  }\\n\\n  .play.is-loaded.stacked {\\n    flex-direction: column;\\n  }\\n\\n  h3 {\\n    margin: 0;\\n    margin-bottom: 0.5em;\\n  }\\n\\n  @media only screen and (max-width: 720px) {\\n    .play:not(.is-loaded) {\\n      flex-direction: column;\\n    }\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AA4OE,OAAO,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,gBAAgB,CAAE,WAAW,CAC7B,SAAS,CAAE,IAAI,AACjB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,IAAI,OAAO,CAAC,IAAI,CAAC,AACnC,CAAC,AAED,KAAK,UAAU,QAAQ,eAAC,CAAC,AACvB,cAAc,CAAE,MAAM,AACxB,CAAC,AAED,EAAE,eAAC,CAAC,AACF,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,KAAK,AACtB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,oBAAK,KAAK,UAAU,CAAC,AAAC,CAAC,AACrB,cAAc,CAAE,MAAM,AACxB,CAAC,AACH,CAAC\"}"
};

const Crossword = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { data = [] } = $$props;
	let { state = {} } = $$props; // {clues: }
	let { actions = ["clear", "reveal", "check", "uncheck"] } = $$props;
	let { theme = "classic" } = $$props;
	let { revealDuration = 1000 } = $$props;
	let { breakpoint = 720 } = $$props;
	let { revealed = false } = $$props;
	let { disableHighlight = false } = $$props;
	let { showCompleteMessage = true } = $$props;
	let { showConfetti = true } = $$props;
	let { showKeyboard } = $$props;
	let { keyboardStyle = "outline" } = $$props;
	let width = 0;
	let focusedDirection = "across";
	let focusedCellIndex = 0;
	let isRevealing = false;
	let isLoaded = false;
	let isChecking = false;
	let revealTimeout;
	let originalClues = [];
	let validated = [];
	let clues = [];
	let cells = [];
	const dispatch = createEventDispatcher();

	const onDataUpdate = () => {
		console.log("onDataUpdate");
		originalClues = createClues(data);
		validated = validateClues(originalClues);
		clues = originalClues.map(d => ({ ...d }));
		cells = createCells(originalClues);
		reset();

		if (state && state.cells) {
			setState(state);
		}
	};

	

	onMount(() => {
		isLoaded = true;
	});

	function checkClues() {
		return clues.map(d => {
			const index = d.index;

			const cellChecks = d.cells.map(c => {
				const { value } = cells.find(e => e.id === c.id);
				const hasValue = !!value;
				const hasCorrect = value === c.answer;
				return { hasValue, hasCorrect };
			});

			const isCorrect = cellChecks.filter(c => c.hasCorrect).length === d.answer.length;
			const isFilled = cellChecks.filter(c => c.hasValue).length === d.answer.length;
			return { ...d, isCorrect, isFilled };
		});
	}

	function reset() {
		isRevealing = false;
		isChecking = false;
		focusedCellIndex = 0;
		focusedDirection = "across";
	}

	/**
 * Setting previous saved state
 * 
 *   answer: "F"
 *   clueNumbers: {down: 1, across: 1}
 *   custom: ""
 *   id: "2-0"
 *   index: 0
 *   number: 1
 *   value: "F"
 *   x: 2
 *   y: 0
 * 
 * @param state
 */
	function setState(state) {
		if (state.cells.length) {
			cells = cells.map(cell => {
				const currCell = state.cells.find(obj => {
					return obj.id === cell.id;
				});

				return { ...cell, value: currCell.value };
			});
		}
	}

	function onClear() {
		reset();
		if (revealTimeout) clearTimeout(revealTimeout);
		cells = cells.map(cell => ({ ...cell, value: "" }));
	}

	function onReveal() {
		if (revealed) return true;
		reset();
		cells = cells.map(cell => ({ ...cell, value: cell.answer }));
		startReveal();
	}

	function onCheck() {
		isChecking = true;
	}

	function onUncheck() {
		isChecking = false;
	}

	const onComplete = () => {
		dispatch("complete", { cellIndexMap });
	};

	function startReveal() {
		isRevealing = true;
		isChecking = false;
		if (revealTimeout) clearTimeout(revealTimeout);

		revealTimeout = setTimeout(
			() => {
				isRevealing = false;
			},
			revealDuration + 250
		);
	}

	if ($$props.data === void 0 && $$bindings.data && data !== void 0) $$bindings.data(data);
	if ($$props.state === void 0 && $$bindings.state && state !== void 0) $$bindings.state(state);
	if ($$props.actions === void 0 && $$bindings.actions && actions !== void 0) $$bindings.actions(actions);
	if ($$props.theme === void 0 && $$bindings.theme && theme !== void 0) $$bindings.theme(theme);
	if ($$props.revealDuration === void 0 && $$bindings.revealDuration && revealDuration !== void 0) $$bindings.revealDuration(revealDuration);
	if ($$props.breakpoint === void 0 && $$bindings.breakpoint && breakpoint !== void 0) $$bindings.breakpoint(breakpoint);
	if ($$props.revealed === void 0 && $$bindings.revealed && revealed !== void 0) $$bindings.revealed(revealed);
	if ($$props.disableHighlight === void 0 && $$bindings.disableHighlight && disableHighlight !== void 0) $$bindings.disableHighlight(disableHighlight);
	if ($$props.showCompleteMessage === void 0 && $$bindings.showCompleteMessage && showCompleteMessage !== void 0) $$bindings.showCompleteMessage(showCompleteMessage);
	if ($$props.showConfetti === void 0 && $$bindings.showConfetti && showConfetti !== void 0) $$bindings.showConfetti(showConfetti);
	if ($$props.showKeyboard === void 0 && $$bindings.showKeyboard && showKeyboard !== void 0) $$bindings.showKeyboard(showKeyboard);
	if ($$props.keyboardStyle === void 0 && $$bindings.keyboardStyle && keyboardStyle !== void 0) $$bindings.keyboardStyle(keyboardStyle);
	$$result.css.add(css$9);
	let $$settled;
	let $$rendered;

	do {
		$$settled = true;
		let focusedCell;
		let cellIndexMap;
		let percentCorrect;
		let isComplete;
		let isDisableHighlight;
		let stacked;
		let inlineStyles;

		 {
			(onDataUpdate());
		}

		focusedCell = cells[focusedCellIndex] || {};
		cellIndexMap = fromPairs(cells.map(cell => [cell.id, cell.index]));
		percentCorrect = cells.filter(d => d.answer === d.value).length / cells.length;
		isComplete = percentCorrect == 1;

		 {
			if (isComplete && cells.length > 0) {
				onComplete();
			}
		}

		isDisableHighlight = isComplete && disableHighlight;

		 {
			(clues = checkClues());
		}

		 {
			(revealed = !clues.filter(d => !d.isCorrect).length);
		}

		stacked = width < breakpoint;
		inlineStyles = themes[theme];

		$$rendered = `${validated
		? `<article class="${"svelte-crossword svelte-186p9qm"}"${add_attribute("style", inlineStyles, 0)}>${slots.toolbar
			? slots.toolbar({ onClear, onReveal, onCheck, onUncheck })
			: `
      ${validate_component(Toolbar, "Toolbar").$$render($$result, { actions }, {}, {})}
    `}

    <div class="${[
				"play svelte-186p9qm",
				(stacked ? "stacked" : "") + " " + (isLoaded ? "is-loaded" : "")
			].join(" ").trim()}">${validate_component(Clues, "Clues").$$render(
				$$result,
				{
					clues,
					cellIndexMap,
					stacked,
					isDisableHighlight,
					isLoaded,
					focusedCellIndex,
					focusedCell,
					focusedDirection
				},
				{
					focusedCellIndex: $$value => {
						focusedCellIndex = $$value;
						$$settled = false;
					},
					focusedCell: $$value => {
						focusedCell = $$value;
						$$settled = false;
					},
					focusedDirection: $$value => {
						focusedDirection = $$value;
						$$settled = false;
					}
				},
				{}
			)}
      ${validate_component(Puzzle, "Puzzle").$$render(
				$$result,
				{
					clues,
					focusedCell,
					isRevealing,
					isChecking,
					isDisableHighlight,
					revealDuration,
					showKeyboard,
					stacked,
					isLoaded,
					keyboardStyle,
					cells,
					focusedCellIndex,
					focusedDirection
				},
				{
					cells: $$value => {
						cells = $$value;
						$$settled = false;
					},
					focusedCellIndex: $$value => {
						focusedCellIndex = $$value;
						$$settled = false;
					},
					focusedDirection: $$value => {
						focusedDirection = $$value;
						$$settled = false;
					}
				},
				{}
			)}</div>

    ${isComplete && !isRevealing && showCompleteMessage
			? `${validate_component(CompletedMessage, "CompletedMessage").$$render($$result, { showConfetti }, {}, {
					default: () => `${slots.message
					? slots.message({})
					: `
          <h3 class="${"svelte-186p9qm"}">You solved it!</h3>
        `}`
				})}`
			: ``}</article>`
		: ``}`;
	} while (!$$settled);

	return $$rendered;
});

var dataNYTDaily = [
	{
		clue: "Bellyache",
		answer: "BEEF",
		direction: "across",
		x: 0,
		y: 0
	},
	{
		clue: "What many people have for public speaking",
		answer: "PHOBIA",
		direction: "across",
		x: 5,
		y: 0
	},
	{
		clue: "\"We ___ loudest when we ___ to ourselves\": Eric Hoffer",
		answer: "LIE",
		direction: "across",
		x: 12,
		y: 0
	},
	{
		clue: "Taj Mahal city",
		answer: "AGRA",
		direction: "across",
		x: 0,
		y: 1
	},
	{
		clue: "College in Manhattan",
		answer: "BARUCH",
		direction: "across",
		x: 5,
		y: 1
	},
	{
		clue: "Halloween time: Abbr.",
		answer: "OCT",
		direction: "across",
		x: 12,
		y: 1
	},
	{
		clue: "Ways to cross a river in Switzerland?",
		answer: "BERNBRIDGES",
		direction: "across",
		x: 0,
		y: 2
	},
	{
		clue: "Big expense for some city dwellers",
		answer: "CAR",
		direction: "across",
		x: 12,
		y: 2
	},
	{
		clue: "Old Glory's land, for short",
		answer: "USOFA",
		direction: "across",
		x: 0,
		y: 3
	},
	{
		clue: "Funny Brooks",
		answer: "MEL",
		direction: "across",
		x: 6,
		y: 3
	},
	{
		clue: "Prop for Mr. Peanut",
		answer: "CANE",
		direction: "across",
		x: 11,
		y: 3
	},
	{
		clue: "Crow, e.g.",
		answer: "TRIBE",
		direction: "across",
		x: 1,
		y: 4
	},
	{
		clue: "Fixed a mistake at a card table",
		answer: "REDEALT",
		direction: "across",
		x: 7,
		y: 4
	},
	{
		clue: "First showing at a film festival in France?",
		answer: "CANNESOPENER",
		direction: "across",
		x: 3,
		y: 5
	},
	{
		clue: "Co. that merged into Verizon",
		answer: "GTE",
		direction: "across",
		x: 0,
		y: 6
	},
	{
		clue: "Owned",
		answer: "HAD",
		direction: "across",
		x: 5,
		y: 6
	},
	{
		clue: "___ Conventions",
		answer: "GENEVA",
		direction: "across",
		x: 9,
		y: 6
	},
	{
		clue: "Supercharge, as an engine",
		answer: "REV",
		direction: "across",
		x: 0,
		y: 7
	},
	{
		clue: "Lightly touch, as with a handkerchief",
		answer: "DAB",
		direction: "across",
		x: 4,
		y: 7
	},
	{
		clue: "Wyoming-to-Missouri dir.",
		answer: "ESE",
		direction: "across",
		x: 8,
		y: 7
	},
	{
		clue: "Chinese dynasty circa A.D. 250",
		answer: "WEI",
		direction: "across",
		x: 12,
		y: 7
	},
	{
		clue: "Actress Brie of \"Mad Men\"",
		answer: "ALISON",
		direction: "across",
		x: 0,
		y: 8
	},
	{
		clue: "Colorful fish",
		answer: "KOI",
		direction: "across",
		x: 7,
		y: 8
	},
	{
		clue: "Creator of sketches, in brief",
		answer: "SNL",
		direction: "across",
		x: 12,
		y: 8
	},
	{
		clue: "Census taker in India?",
		answer: "DELHICOUNTER",
		direction: "across",
		x: 0,
		y: 9
	},
	{
		clue: "Like Barack Obama's presidency",
		answer: "TWOTERM",
		direction: "across",
		x: 1,
		y: 10
	},
	{
		clue: "Loads",
		answer: "SLEWS",
		direction: "across",
		x: 9,
		y: 10
	},
	{
		clue: "Denny's competitor",
		answer: "IHOP",
		direction: "across",
		x: 0,
		y: 11
	},
	{
		clue: "Mensa stats",
		answer: "IQS",
		direction: "across",
		x: 6,
		y: 11
	},
	{
		clue: "Urban sitting spot",
		answer: "STOOP",
		direction: "across",
		x: 10,
		y: 11
	},
	{
		clue: "Classic tattoo word",
		answer: "MOM",
		direction: "across",
		x: 0,
		y: 12
	},
	{
		clue: "Police dragnet in South Korea?",
		answer: "SEOULSEARCH",
		direction: "across",
		x: 4,
		y: 12
	},
	{
		clue: "Spanish article",
		answer: "UNA",
		direction: "across",
		x: 0,
		y: 13
	},
	{
		clue: "How café may be served",
		answer: "AULAIT",
		direction: "across",
		x: 4,
		y: 13
	},
	{
		clue: "\"If you're asking me,\" in textspeak",
		answer: "IMHO",
		direction: "across",
		x: 11,
		y: 13
	},
	{
		clue: "W-2 fig.",
		answer: "SSN",
		direction: "across",
		x: 0,
		y: 14
	},
	{
		clue: "Fairly",
		answer: "PRETTY",
		direction: "across",
		x: 4,
		y: 14
	},
	{
		clue: "\"___ Eyes\" (1975 Eagles hit)",
		answer: "LYIN",
		direction: "across",
		x: 11,
		y: 14
	},
	{
		clue: "Hindu title of respect",
		answer: "BABU",
		direction: "down",
		x: 0,
		y: 0
	},
	{
		clue: "Expel",
		answer: "EGEST",
		direction: "down",
		x: 1,
		y: 0
	},
	{
		clue: "Misspeaking, e.g.",
		answer: "ERROR",
		direction: "down",
		x: 2,
		y: 0
	},
	{
		clue: "Some derivative stories, colloquially",
		answer: "FANFIC",
		direction: "down",
		x: 3,
		y: 0
	},
	{
		clue: "Brew with hipster cred",
		answer: "PBR",
		direction: "down",
		x: 5,
		y: 0
	},
	{
		clue: "American pop-rock band composed of three sisters",
		answer: "HAIM",
		direction: "down",
		x: 6,
		y: 0
	},
	{
		clue: "Said \"I'll have ...\"",
		answer: "ORDERED",
		direction: "down",
		x: 7,
		y: 0
	},
	{
		clue: "Cone-shaped corn snacks",
		answer: "BUGLES",
		direction: "down",
		x: 8,
		y: 0
	},
	{
		clue: "Swelling reducer",
		answer: "ICE",
		direction: "down",
		x: 9,
		y: 0
	},
	{
		clue: "Sounds of satisfaction",
		answer: "AHS",
		direction: "down",
		x: 10,
		y: 0
	},
	{
		clue: "Broadcast often seen at 6:00 p.m. and 11:00 p.m.",
		answer: "LOCALNEWS",
		direction: "down",
		x: 12,
		y: 0
	},
	{
		clue: "\"That is too much for me\"",
		answer: "ICANTEVEN",
		direction: "down",
		x: 13,
		y: 0
	},
	{
		clue: "To be: Fr.",
		answer: "ETRE",
		direction: "down",
		x: 14,
		y: 0
	},
	{
		clue: "Cake with rum",
		answer: "BABA",
		direction: "down",
		x: 4,
		y: 2
	},
	{
		clue: "Battle of Normandy city",
		answer: "CAEN",
		direction: "down",
		x: 11,
		y: 3
	},
	{
		clue: "Increase, as resolution",
		answer: "ENHANCE",
		direction: "down",
		x: 5,
		y: 4
	},
	{
		clue: "Watches Bowser, say",
		answer: "DOGSITS",
		direction: "down",
		x: 9,
		y: 4
	},
	{
		clue: "Dueling sword",
		answer: "EPEE",
		direction: "down",
		x: 10,
		y: 4
	},
	{
		clue: "Catch",
		answer: "NAB",
		direction: "down",
		x: 6,
		y: 5
	},
	{
		clue: "Skate park feature",
		answer: "RAIL",
		direction: "down",
		x: 14,
		y: 5
	},
	{
		clue: "Many a May or June honoree",
		answer: "GRAD",
		direction: "down",
		x: 0,
		y: 6
	},
	{
		clue: "Some fund-raisers",
		answer: "TELETHONS",
		direction: "down",
		x: 1,
		y: 6
	},
	{
		clue: "1975 hit by the Electric Light Orchestra",
		answer: "EVILWOMAN",
		direction: "down",
		x: 2,
		y: 6
	},
	{
		clue: "\"Just ___\" (Nike slogan)",
		answer: "DOIT",
		direction: "down",
		x: 4,
		y: 7
	},
	{
		clue: "Very long time",
		answer: "EON",
		direction: "down",
		x: 8,
		y: 7
	},
	{
		clue: "Union workplace",
		answer: "SHOP",
		direction: "down",
		x: 3,
		y: 8
	},
	{
		clue: "Small citrus fruit",
		answer: "KUMQUAT",
		direction: "down",
		x: 7,
		y: 8
	},
	{
		clue: "Baltimore athlete",
		answer: "ORIOLE",
		direction: "down",
		x: 6,
		y: 9
	},
	{
		clue: "If-___ (computer programming statement)",
		answer: "ELSE",
		direction: "down",
		x: 10,
		y: 9
	},
	{
		clue: "Wholesale's opposite",
		answer: "RETAIL",
		direction: "down",
		x: 11,
		y: 9
	},
	{
		clue: "Like a bad apple",
		answer: "WORMY",
		direction: "down",
		x: 12,
		y: 10
	},
	{
		clue: "2014 Winter Olympics locale",
		answer: "SOCHI",
		direction: "down",
		x: 13,
		y: 10
	},
	{
		clue: "\"___ in the Morning\" (bygone radio show)",
		answer: "IMUS",
		direction: "down",
		x: 0,
		y: 11
	},
	{
		clue: "Narrow opening",
		answer: "SLIT",
		direction: "down",
		x: 8,
		y: 11
	},
	{
		clue: "Sound: Prefix",
		answer: "PHON",
		direction: "down",
		x: 14,
		y: 11
	},
	{
		clue: "Gradually weaken",
		answer: "SAP",
		direction: "down",
		x: 4,
		y: 12
	},
	{
		clue: "Home of most of the members of NATO: Abbr.",
		answer: "EUR",
		direction: "down",
		x: 5,
		y: 12
	},
	{
		clue: "Total mess",
		answer: "STY",
		direction: "down",
		x: 9,
		y: 12
	}
];

var dataNYTDailyMini = [
	{
		clue: "The 1% of 1% milk",
		answer: "FAT",
		direction: "across",
		x: 2,
		y: 0
	},
	{
		clue: "Flicker of light",
		answer: "GLINT",
		direction: "across",
		x: 0,
		y: 1
	},
	{
		clue: "Really neat",
		answer: "NIFTY",
		direction: "across",
		x: 0,
		y: 2
	},
	{
		clue: "\"__ we meet again\"",
		answer: "UNTIL",
		direction: "across",
		x: 0,
		y: 3
	},
	{
		clue: "It's way over your head",
		answer: "SKY",
		direction: "across",
		x: 0,
		y: 4
	},
	{
		clue: "Point bonus for using all seven tiles in Scrabble",
		answer: "FIFTY",
		direction: "down",
		x: 2,
		y: 0
	},
	{
		clue: "Opposite of pro-",
		answer: "ANTI",
		direction: "down",
		x: 3,
		y: 0
	},
	{
		clue: "Texter's \"gotta run\"",
		answer: "TTYL",
		direction: "down",
		x: 4,
		y: 0
	},
	{
		clue: "Migratory antelopes",
		answer: "GNUS",
		direction: "down",
		x: 0,
		y: 1
	},
	{
		clue: "Clickable part of a webpage",
		answer: "LINK",
		direction: "down",
		x: 1,
		y: 1
	}
];

var cells = [
	{
		id: "2-0",
		number: 1,
		clueNumbers: {
			down: 1,
			across: 1
		},
		x: 2,
		y: 0,
		value: "F",
		answer: "F",
		custom: "",
		index: 0
	},
	{
		id: "3-0",
		number: 2,
		clueNumbers: {
			across: 1,
			down: 2
		},
		x: 3,
		y: 0,
		value: "",
		answer: "A",
		custom: "",
		index: 1
	},
	{
		id: "4-0",
		number: 3,
		clueNumbers: {
			across: 1,
			down: 3
		},
		x: 4,
		y: 0,
		value: "",
		answer: "T",
		custom: "",
		index: 2
	},
	{
		id: "0-1",
		number: 4,
		clueNumbers: {
			down: 4,
			across: 4
		},
		x: 0,
		y: 1,
		value: "",
		answer: "G",
		custom: "",
		index: 3
	},
	{
		id: "1-1",
		number: 5,
		clueNumbers: {
			across: 4,
			down: 5
		},
		x: 1,
		y: 1,
		value: "",
		answer: "L",
		custom: "",
		index: 4
	},
	{
		id: "2-1",
		number: "",
		clueNumbers: {
			down: 1,
			across: 4
		},
		x: 2,
		y: 1,
		value: "",
		answer: "I",
		custom: "",
		index: 5
	},
	{
		id: "3-1",
		number: "",
		clueNumbers: {
			down: 2,
			across: 4
		},
		x: 3,
		y: 1,
		value: "",
		answer: "N",
		custom: "",
		index: 6
	},
	{
		id: "4-1",
		number: "",
		clueNumbers: {
			down: 3,
			across: 4
		},
		x: 4,
		y: 1,
		value: "",
		answer: "T",
		custom: "",
		index: 7
	},
	{
		id: "0-2",
		number: 6,
		clueNumbers: {
			down: 4,
			across: 6
		},
		x: 0,
		y: 2,
		value: "",
		answer: "N",
		custom: "",
		index: 8
	},
	{
		id: "1-2",
		number: "",
		clueNumbers: {
			down: 5,
			across: 6
		},
		x: 1,
		y: 2,
		value: "",
		answer: "I",
		custom: "",
		index: 9
	},
	{
		id: "2-2",
		number: "",
		clueNumbers: {
			down: 1,
			across: 6
		},
		x: 2,
		y: 2,
		value: "",
		answer: "F",
		custom: "",
		index: 10
	},
	{
		id: "3-2",
		number: "",
		clueNumbers: {
			down: 2,
			across: 6
		},
		x: 3,
		y: 2,
		value: "",
		answer: "T",
		custom: "",
		index: 11
	},
	{
		id: "4-2",
		number: "",
		clueNumbers: {
			down: 3,
			across: 6
		},
		x: 4,
		y: 2,
		value: "",
		answer: "Y",
		custom: "",
		index: 12
	},
	{
		id: "0-3",
		number: 7,
		clueNumbers: {
			down: 4,
			across: 7
		},
		x: 0,
		y: 3,
		value: "",
		answer: "U",
		custom: "",
		index: 13
	},
	{
		id: "1-3",
		number: "",
		clueNumbers: {
			down: 5,
			across: 7
		},
		x: 1,
		y: 3,
		value: "",
		answer: "N",
		custom: "",
		index: 14
	},
	{
		id: "2-3",
		number: "",
		clueNumbers: {
			down: 1,
			across: 7
		},
		x: 2,
		y: 3,
		value: "",
		answer: "T",
		custom: "",
		index: 15
	},
	{
		id: "3-3",
		number: "",
		clueNumbers: {
			down: 2,
			across: 7
		},
		x: 3,
		y: 3,
		value: "",
		answer: "I",
		custom: "",
		index: 16
	},
	{
		id: "4-3",
		number: "",
		clueNumbers: {
			down: 3,
			across: 7
		},
		x: 4,
		y: 3,
		value: "",
		answer: "L",
		custom: "",
		index: 17
	},
	{
		id: "0-4",
		number: 8,
		clueNumbers: {
			down: 4,
			across: 8
		},
		x: 0,
		y: 4,
		value: "",
		answer: "S",
		custom: "",
		index: 18
	},
	{
		id: "1-4",
		number: "",
		clueNumbers: {
			down: 5,
			across: 8
		},
		x: 1,
		y: 4,
		value: "",
		answer: "K",
		custom: "",
		index: 19
	},
	{
		id: "2-4",
		number: "",
		clueNumbers: {
			down: 1,
			across: 8
		},
		x: 2,
		y: 4,
		value: "",
		answer: "Y",
		custom: "",
		index: 20
	}
];
var dataNYTDailyMiniState = {
	cells: cells
};

/* App.svelte generated by Svelte v3.29.0 */

const css$a = {
	code: "article.svelte-pu4ii9.svelte-pu4ii9{max-width:960px;margin:0 auto;padding:1em;font-family:sans-serif}section.svelte-pu4ii9.svelte-pu4ii9{max-width:960px;margin:5em 0}.info.svelte-pu4ii9.svelte-pu4ii9{max-width:640px;margin:1em 0;text-align:left;font-size:1.125em}.info.svelte-pu4ii9 a.svelte-pu4ii9{margin-right:0.25em}h2.svelte-pu4ii9.svelte-pu4ii9{font-size:1.5em;padding-top:1em}p.svelte-pu4ii9.svelte-pu4ii9{margin:1em auto}button.svelte-pu4ii9.svelte-pu4ii9{cursor:pointer}",
	map: "{\"version\":3,\"file\":\"App.svelte\",\"sources\":[\"App.svelte\"],\"sourcesContent\":[\"<script>\\n  import Crossword from \\\"../src/Crossword.svelte\\\";\\n  import dataNYTDaily from \\\"./data/nyt-daily.json\\\";\\n  import dataNYTDailyMini from \\\"./data/nyt-mini.json\\\";\\n  import dataNYTDailyMiniState from \\\"./data/nyt-mini-state.json\\\";\\n  // import savedState from \\\"./savedState.js\\\";\\n\\n  // console.log(savedState);\\n\\n  function onComplete() {\\n    console.log('onComplete');\\n  }\\n\\n  function onCellChange(event) {\\n    console.log('onCellChange', event);\\n  }\\n\\n</script>\\n\\n<article>\\n  <section id=\\\"default\\\">\\n    <div class=\\\"info\\\">\\n      <h2><a href=\\\"#default\\\">Default Example</a></h2>\\n      <p>\\n        A\\n        <a href=\\\"https://www.nytimes.com/crosswords/game/daily/2020/10/21\\\"\\n          >NYT daily</a\\n        >\\n        puzzle with all default settings. hello world!\\n\\n      </p>\\n    </div>\\n    <Crossword data=\\\"{dataNYTDailyMini}\\\" on:complete={onComplete} on:cellChange={onCellChange} state={dataNYTDailyMiniState} />\\n  </section>\\n\\n  <section id=\\\"simple-customization\\\">\\n    <div class=\\\"info\\\">\\n      <h2><a href=\\\"#simple\\\">With TIimer</a></h2>\\n      <p>\\n        With timer\\n      </p>\\n    </div>\\n    <Crossword\\n      data=\\\"{dataNYTDaily}\\\"\\n      actions=\\\"{[\\\"clear\\\", \\\"reveal\\\", \\\"timer\\\"]}\\\"\\n    />\\n  </section>\\n\\n  <section id=\\\"slots\\\">\\n    <div class=\\\"info\\\">\\n      <h2><a href=\\\"#slots\\\">Slots</a></h2>\\n      <p>Custom slots for the toolbar and completion message.</p>\\n    </div>\\n    <Crossword data=\\\"{dataNYTDaily}\\\">\\n      <div\\n        class=\\\"toolbar\\\"\\n        slot=\\\"toolbar\\\"\\n        let:onClear\\n        let:onReveal\\n        style=\\\"background: #333; padding: 1em; margin: 1em 0;\\\"\\n      >\\n        <button\\n          style=\\\"font-size: 1.5em; background-color: #888;\\\"\\n          on:click=\\\"{onClear}\\\">clear puzzle</button\\n        >\\n        <button\\n          style=\\\"font-size: 1.5em; background-color: #888;\\\"\\n          on:click=\\\"{onReveal}\\\">show answers</button\\n        >\\n      </div>\\n      <div slot=\\\"message\\\">\\n        <h3>OMG, congrats!</h3>\\n        <img\\n          alt=\\\"celebration\\\"\\n          src=\\\"https://media3.giphy.com/media/QpOZPQQ2wbjOM/giphy.gif\\\"\\n        />\\n      </div>\\n    </Crossword>\\n  </section>\\n</article>\\n\\n<style>\\n  article {\\n    max-width: 960px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    font-family: sans-serif;\\n  }\\n  section {\\n    max-width: 960px;\\n    margin: 5em 0;\\n  }\\n\\n  .info {\\n    max-width: 640px;\\n    margin: 1em 0;\\n    text-align: left;\\n    font-size: 1.125em;\\n  }\\n  .info a {\\n    margin-right: 0.25em;\\n  }\\n  h2 {\\n    font-size: 1.5em;\\n    padding-top: 1em;\\n  }\\n  p {\\n    margin: 1em auto;\\n  }\\n  button {\\n    cursor: pointer;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAkFE,OAAO,4BAAC,CAAC,AACP,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,WAAW,CAAE,UAAU,AACzB,CAAC,AACD,OAAO,4BAAC,CAAC,AACP,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,AACf,CAAC,AAED,KAAK,4BAAC,CAAC,AACL,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,OAAO,AACpB,CAAC,AACD,mBAAK,CAAC,CAAC,cAAC,CAAC,AACP,YAAY,CAAE,MAAM,AACtB,CAAC,AACD,EAAE,4BAAC,CAAC,AACF,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,AAClB,CAAC,AACD,CAAC,4BAAC,CAAC,AACD,MAAM,CAAE,GAAG,CAAC,IAAI,AAClB,CAAC,AACD,MAAM,4BAAC,CAAC,AACN,MAAM,CAAE,OAAO,AACjB,CAAC\"}"
};

const App = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	$$result.css.add(css$a);

	return `<article class="${"svelte-pu4ii9"}"><section id="${"default"}" class="${"svelte-pu4ii9"}"><div class="${"info svelte-pu4ii9"}"><h2 class="${"svelte-pu4ii9"}"><a href="${"#default"}" class="${"svelte-pu4ii9"}">Default Example</a></h2>
      <p class="${"svelte-pu4ii9"}">A
        <a href="${"https://www.nytimes.com/crosswords/game/daily/2020/10/21"}" class="${"svelte-pu4ii9"}">NYT daily</a>
        puzzle with all default settings. hello world!

      </p></div>
    ${validate_component(Crossword, "Crossword").$$render(
		$$result,
		{
			data: dataNYTDailyMini,
			state: dataNYTDailyMiniState
		},
		{},
		{}
	)}</section>

  <section id="${"simple-customization"}" class="${"svelte-pu4ii9"}"><div class="${"info svelte-pu4ii9"}"><h2 class="${"svelte-pu4ii9"}"><a href="${"#simple"}" class="${"svelte-pu4ii9"}">With TIimer</a></h2>
      <p class="${"svelte-pu4ii9"}">With timer
      </p></div>
    ${validate_component(Crossword, "Crossword").$$render(
		$$result,
		{
			data: dataNYTDaily,
			actions: ["clear", "reveal", "timer"]
		},
		{},
		{}
	)}</section>

  <section id="${"slots"}" class="${"svelte-pu4ii9"}"><div class="${"info svelte-pu4ii9"}"><h2 class="${"svelte-pu4ii9"}"><a href="${"#slots"}" class="${"svelte-pu4ii9"}">Slots</a></h2>
      <p class="${"svelte-pu4ii9"}">Custom slots for the toolbar and completion message.</p></div>
    ${validate_component(Crossword, "Crossword").$$render($$result, { data: dataNYTDaily }, {}, {
		toolbar: ({ onClear, onReveal }) => `<div class="${"toolbar"}" slot="${"toolbar"}" style="${"background: #333; padding: 1em; margin: 1em 0;"}"><button style="${"font-size: 1.5em; background-color: #888;"}" class="${"svelte-pu4ii9"}">clear puzzle</button>
        <button style="${"font-size: 1.5em; background-color: #888;"}" class="${"svelte-pu4ii9"}">show answers</button></div>`,
		message: () => `<div slot="${"message"}"><h3>OMG, congrats!</h3>
        <img alt="${"celebration"}" src="${"https://media3.giphy.com/media/QpOZPQQ2wbjOM/giphy.gif"}"></div>`,
		default: () => `
      `
	})}</section>
</article>`;
});

module.exports = App;
